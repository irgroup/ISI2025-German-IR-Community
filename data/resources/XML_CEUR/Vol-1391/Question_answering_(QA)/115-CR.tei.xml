<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,152.06,116.95,311.23,12.62;1,138.77,134.89,337.80,12.62">LIMSI-CNRS@CLEF 2015: Tree Edit Beam Search for Multiple Choice Question Answering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName coords="1,225.85,172.57,60.15,8.74"><forename type="first">Martin</forename><surname>Gleize</surname></persName>
							<email>gleize@limsi.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">LIMSI-CNRS</orgName>
								<address>
									<addrLine>Rue John von Neumann</addrLine>
									<postCode>91405</postCode>
									<settlement>Orsay CEDEX</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Université Paris-Sud</orgName>
								<address>
									<settlement>Orsay</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,319.49,172.57,59.22,8.74"><forename type="first">Brigitte</forename><surname>Grau</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">LIMSI-CNRS</orgName>
								<address>
									<addrLine>Rue John von Neumann</addrLine>
									<postCode>91405</postCode>
									<settlement>Orsay CEDEX</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="laboratory">ENSIIE</orgName>
								<address>
									<settlement>Evry</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,152.06,116.95,311.23,12.62;1,138.77,134.89,337.80,12.62">LIMSI-CNRS@CLEF 2015: Tree Edit Beam Search for Multiple Choice Question Answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0EA721A10573F189B3AAF5EC4E5884E2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Question Answering</term>
					<term>Passage Retrieval</term>
					<term>Textual Entailment</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes our participation to the Entrance Exams Task of CLEF 2015's Question Answering Track. The goal is to answer multiple-choice questions on short texts. Our system first retrieves passages relevant to the question, through lexical expansion involving WordNet and word vectors. Then a tree edit model is used on graph representations of the passages and answer choices to extract edit sequences. Finally, features are computed from those edit sequences and used in various machine-learned models to take the final decision. We submitted several runs in the task, one of which yielding a c@1 of 0.36, which makes our team the second best on the task.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The task focuses on the reading of single documents and identification of the correct answer to a question from a set of possible answer options. The identification of the correct answer requires various kinds of inference and the consideration of previously acquired background knowledge. Japanese University Entrance Exams include questions formulated at various levels of complexity and test a wide range of capabilities. The challenge of "Entrance Exams" aims at evaluating systems under the same conditions humans are evaluated to enter the University. Previously the evaluation campaign Question Answering For Machine Reading Evaluation (QA4MRE at CLEF) <ref type="bibr" coords="1,350.20,541.38,10.52,8.74" target="#b7">[8]</ref> focused on multiple-choice questions designed to evaluate computer systems, but this relatively new task takes on challenges typically offered to humans. It naturally translates into more complex inference phenomena to solve <ref type="bibr" coords="1,304.77,577.24,9.96,8.74" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">System Architecture</head><p>The overarching goal of our system is essentially to validate correct answers without invalidating them, and invalidate wrong answers without validating them. The architecture of our multiple-choice question-answering system is described in Figure <ref type="figure" coords="2,177.34,119.99,3.87,8.74" target="#fig_1">1</ref>. Its pipeline is composed of mainly five modules: preprocessing, passage retrieval, graph enrichment, beam search with tree edit model and final classifiers for validation/invalidation. The remaining of this section is dedicated to the detailed description of those modules.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preprocessing</head><p>We use Stanford CoreNLP as the main Natural Language annotation tool. Each sentence from the document, questions or answer choices is tagged with Part-Of-Speech <ref type="bibr" coords="2,182.32,561.47,10.52,8.74" target="#b8">[9]</ref> and syntactically parsed <ref type="bibr" coords="2,306.02,561.47,9.96,8.74" target="#b3">[4]</ref>. In addition, a coreference resolution system <ref type="bibr" coords="2,167.08,573.43,10.52,8.74" target="#b6">[7]</ref> is applied on the whole document as well as question-answer pairs. We add to this coreference resolution process manual rules derived from the data, like replacing first person pronouns in non-dialogue context with "the author" or "the writer", depending on which is used in the questions. Named Entity Recognition was not used, due to not being very helpful in past editions of Entrance Exams. NER is very important to factoid QA, because it produces annotations which correspond roughly to the expected type of answer, but on complex multiple-choice questions which rarely use entities as an answer type, it is intuitively less crucial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Passage Retrieval</head><p>The passage retrieval module aims at extracting relevant short snippets from the document to pass to the more computationally expensive modules further down the pipeline. Words of the question and the answer choice act as the query. However, it is very rare that words of the question exactly appear in the relevant passage of the document, so we have to use some form of query expansion. We enrich the lemmas with coreference information, WordNet relations (synonyms, antonyms, hypernyms, hyponyms), and weigh the words by the IDF score of the original word in the document. If the words of the query are not found using the previous expansion methods, we use a vector-based representation of words to compute a similarity measure. Word vectors are those found in <ref type="bibr" coords="3,277.55,303.57,9.96,8.74" target="#b2">[3]</ref>. To each word, we assign a vector of 50 values. <ref type="bibr" coords="3,155.25,315.52,10.33,8.74" target="#b2">[3]</ref>'s resource actually provides multiple vectors for each word, to account more accurately for polysemy, so we use the same window-based disambiguation method as the author to compute the right one. We then pair the query word vectors with the document word vectors with the highest cosine similarity. We also take into account bigram vectors, by summing 2 vectors, which means that we can effectively handle 1-to-2, 2-to-1 and 2-to-2 scored alignments. Passages are ranked according to the scoring function defined by Equation <ref type="formula" coords="3,456.83,387.25,4.98,8.74" target="#formula_0">1</ref>and are then naturally extended to the full sequence of sentences they span.</p><formula xml:id="formula_0" coords="3,160.80,420.09,319.80,30.32">score(passage) = #matchedW ords #queryW ords × n-1 i=1 score(w i ) + score(w i+1 ) dist(i, i + 1) 2<label>(1)</label></formula><p>We take into account the potential absence of query words by multiplying the passage score by the fraction of query words the passage contains. Each w i ∈ {w 1 , ..., w n } a document word matching a query word is given a simple alignment score (1 if they have same lemmas, 0.9 if they are WordNet synonyms, 0.8 if they are in another WordNet relation, and their word vector cosine similarity otherwise), weighted with the IDF of the word, and the formula is normalized by the square of the distance between the words in the sentence. Overall, this passage retrieval method retrieves a lot of short passages, most of which will overlap or won't be correct, but the beam search which uses them is designed to handle numerous source passages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Graph Enrichment</head><p>The passages were syntactically parsed with Stanford CoreNLP to obtain the initial dependency graphs. We fuse those graphs together by linking their roots with a followed-by arc which materializes in the single remaining graph that a sentence is followed by another in the passage. Then we use ConceptNet <ref type="bibr" coords="3,457.59,657.11,10.52,8.74" target="#b4">[5]</ref> to enrich the graph. ConceptNet is a semantic triplet base containing relations about common-knowledge of the world, designed to be used especially for machine understanding of text written by people. It is built from nodes representing words or short phrases of natural language, and labeled relationships between them (the nodes are called "concepts" for tradition, but they'd be better known as "terms".) For example, ConceptNet contains everyday basic knowledge, like MotivatedByGoal(learn, knowledge): you would learn because you want knowledge. It also contains cultural knowledge, like UsedFor(saxophone, jazz): a saxophone is used for jazz.</p><p>Our assumption is that understanding the documents in the Entrance exams corpus requires a lot of human common-sense, easily acquired by human readers of that level, but difficult to grasp for computers. So we want to enrich the text with relations which attempt to fill that gap.</p><p>Concepts from ConceptNet are mainly single words, like "saxophone" or "jazz", so they are easy to link to our original graph. However, it is not easy to integrate relations to our graph, because they have labels that are potentially composed of several words, like UsedFor or MotivatedByGoal. We could split those labels into words and use those in the graph, but we preferred attaching to the original graph the parse tree of the surfaceText element of the relations. Surface texts are the original natural language text that expressed the statement, like "a saxophone is used for jazz". We attach the parse tree of these sentences to any concept whose head word is in the original graph. We only retrieve from ConceptNet relations that are indicative of an entailment relation of any kind, namely: IsA, PartOf, MemberOf, UsedFor, CapableOf, Causes, HasPrerequisite, MotivatedByGoal, Desires.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Tree edit beam search</head><p>Tree edit model Our goal is to characterize a sequence of transformations applied to the passage to obtain the answer choice. Those transformations affect the graph built in the previous section, which is made of parse trees, and the transformations will be called edits, hence a tree edit model. Basically, we apply different edits iteratively to the tree, modifying it each time, so that the edited tree is closer to the tree of the answer choice. When we find an edit sequence to turn the passage into the answer choice, we look at the nature of edits that were effectively applied, and if they are elements of proof that the passage is indeed close to the answer choice, or if it is too far to conclude anything. This will be done in the subsequent sections. Table <ref type="table" coords="4,161.92,578.36,4.98,8.74" target="#tab_0">1</ref> presents the supported edit operations. Figure <ref type="figure" coords="4,373.77,578.36,4.98,8.74">2</ref> presents an example of successive applications of three of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Beam search</head><p>The main problem is that there are many choices to make when applying an edit. Which edit to choose? Where to apply changes in the tree? What new elements must be added? What to do next? Any of these choices is an easy source of error, so rather than picking one each time and hoping to find Replace the word attached to the node t with w. Move(m: Tree, op: Tree, np: Tree) Move the subtree m from under op to under np.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. Examples of successive edit operations</head><p>the right edit sequence, we apply a lot of the possible edits, and explore only the most promising using a satisfyingly good heuristic. Beam search is an optimization of best-first search that reduces its memory requirements. It uses breadth-first search to build its search space. At each step of the search, we generate all possible edits of the trees at the current step, sorting them in increasing order of heuristic cost defined below. However, we only store a predetermined number of best trees at each level, called the beam width. Only those trees are edited next and the rest is discarded. This method allows to finetune via the beam width the probability to find useful edit sequences and the memory and time costs.</p><p>Partial Tree Kernel as a heuristic We need a heuristic measure of how far a tree at the current step is from the target tree (the dependency tree of an answer choice). We implement the Partial Tree Kernel defined in <ref type="bibr" coords="5,418.07,500.67,10.52,8.74" target="#b5">[6]</ref> to compute the similarity between the current tree and the target tree. As a tree kernel, it classically computes the number of common subtrees between 2 trees, but this particular version of the tree kernel is adapted to n-ary trees, which is what we have in dependency structures. The kernel computation is normalized with</p><formula xml:id="formula_1" coords="5,137.41,558.69,109.89,16.59">K(x, y) = K(x,y) √ K(x,x) √ K(y,y)</formula><p>, for K the kernel and x, y the trees.</p><p>Algorithm At the start of the algorithm, the working set consists solely of the enriched dependency graphs of all the retrieved passages. The target tree is the answer choice (or the question plus the answer choice when the answer is an end to the question sentence as can be the case in the CLEF dataset). In our experiments, we keep at most 10 passages in the retrieval step. Then, every possible relevant edit operation is applied to each passage. Inserts and renames can only add a node that is present in the target tree. Moves can only move a node under a parent so that the link parent → child is present in the target tree. Those edited trees are added to the working set, and the partial tree kernel with the target tree is computed for all of them. The working set is then filtered to only the top 50 trees with the best kernel score (50 is our beam width) and the algorithm can now start again with the application of the edit operations on the new working set. It stops when 10 different edit sequences have been found (some filtering is done to ensure that we do not obtain mere variations of the first sequence found), or after 200 edit steps, whichever comes first.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Feature extraction</head><p>The goal is to classify an edit sequence with two different machine-learned classifiers, one to decide if the related answer choice is validated, and one to decide if it is invalidated. The design of features is thus primordial. In practice, we will use the same features and the same machine learning algorithm for the two classifiers, so the only difference will be the training data, discussed in next section. Most features are counts of specific edit unigrams or bigrams in the edit sequence, and are summarized in Table <ref type="table" coords="6,302.71,373.80,3.87,8.74" target="#tab_1">2</ref>. Pre-processing informations that were not used in the beam search are used at this point, like dependency relations in the parse tree, coreferences, and whether what we edit was part of the Concept-Net additions or can be linked in WordNet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiments and results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">CLEF 2015 QA Track: Entrance Exams data and evaluation</head><p>Our data consist of the trial and test sets at CLEF 2015 Question Answering Track, Task 2: Entrance Exams. The trial data is composed of the test sets at CLEF 2013 and 2014, each containing a series of 12 texts, and for each of them, 4 to 6 multiple-choice questions to answer, for about 120 questions in total. In the 2015 test set, there are 19 documents, and a total of 89 questions. There are 4 answer choices possible for each of the questions. This corpus has been extracted from the Tokyo University Entrance Exam in English as a foreign language. Systems are evaluated according to their c@1, defined in equation 2.</p><formula xml:id="formula_2" coords="6,256.57,612.61,219.78,22.31">C@1 = 1 n (n R + n U n R n ) (<label>2</label></formula><formula xml:id="formula_3" coords="6,476.34,619.35,4.24,8.74">)</formula><p>with n the total number of questions, n R the number of correctly answered questions, n U the number of unanswered questions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Learning classifiers</head><p>The classifier pair, for validation and invalidation, uses the feature set defined in the previous section. We experimented with two models, logistic regression and random forest, both implemented in Weka <ref type="bibr" coords="8,324.35,166.43,9.96,8.74" target="#b1">[2]</ref>, and results are presented in the next subsection. We focus here on how we built our training data. What we want to avoid is trying to learn how to transform any random text snippet in the document into any random answer choice, because it serves no purpose. Indeed, as readers, we cannot validate the right answer choice by looking at a couple of arbitrary sentences in the text, nor can we invalidate a wrong answer choice if the passage we are reading is not even related to the question. Thus, we annotate the relevant passages in the training data manually, and our algorithm runs on them, without a passage retrieval phase. A relevant passage is roughly the sufficient text snippet which expresses both the question and the elements of the answer choice. Of course, sometimes the answer choice is not exactly expressed by the passage, as commonly happens for wrong answer choices, and sometimes, albeit rarely, the answer choice is not even expressed at all in the document. Two answer choices to the same question can share a relevant passage, as we annotate complete sentences. We create the learning (passage, answer choice) pairs by annotating them following the semantics described in Figure <ref type="figure" coords="8,318.81,357.71,3.87,8.74" target="#fig_2">3</ref>. In this figure, RP stands for right passage, RA for right answer, WA for any wrong answer, WAx for the wrong answer choice x, WPx for the passage expressing it, OP for any other passage than the one expressing the paired answer choice. To summarize, the only time we can either validate or invalidate are when we operate on passages relevant to some answer choice: we annotate as validated only if we have both the right passage and the right answer, and invalidated if we have a wrong answer choice with either the passage which expresses it in the document or the right passage. This follows the intuition that as readers, given a question, a passage and an answer choice, we can probably tell if the provided passage is self-sufficient in expressing the right answer to the question or if there is a mismatch between an answer choice and the passage in the text it refers to. Then the edit sequences for this data are computed, their features are extracted, and sequences for both classifiers are labeled using the aforementioned semantics. Implicitly, as this is not visible in Figure <ref type="figure" coords="8,336.34,525.09,3.87,8.74" target="#fig_2">3</ref>, if an edit sequence is labeled 1 (valide/invalidate) for one classifier, it is labeled 0 for the other. The thin dashed arrows simply symbolize that the label is 0 for both classifiers.</p><p>For the test run, the algorithm runs on the test data, and the answer is chosen based on the regression numbers output by the two classifiers. First, for each answer choice, the edit sequence with the highest max (validationScore, invalidationScore) is selected. Ideally we want an edit sequence which is characteristic of either a high confidence validation, or a high confidence invalidation, so that we may classify the answer choice confidently as either correct or incorrect in the next step. Then, the answer choice whose selected sequence has the highest validationScore -invalidationScore is finally picked: we want in correctly classified answer choices as much separation between their validation and invalidation scores as possible. If they have a similar validation and invalidation score, the system just ends up guessing. We acknowledge that this is a very basic decision process and address this point more in detail in Section 3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Results</head><p>In this section, we report the results of our two learning models on the testing set of questions. Table <ref type="table" coords="9,233.50,483.38,4.98,8.74" target="#tab_2">3</ref> presents those results. A c@1 of 0.36 gave us the second place among teams which participated in the task. The random forest model performed better on the test run, which confirms what we expected during development.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Error analysis</head><p>Qualitative analysis A pertinent qualitative analysis is always delicate to do for machine learning systems with such low performances. It is indeed always possible to draw examples that look like the system is obviously supposed to correctly handle but end up as errors. Conversely, it is always possible to find a complex instance on which the system somewhat miraculously worked (i.e. made a lucky guess). Nevertheless, we first report some of the simple errors that our system made. In the following passage/question pair, our system got lured by answer 3, closest in surface form to the relevant passage. ConceptNet does not link "held" to "trapped", and "its original nature" from the correct answer could not be linked to anything in the passage (it is however found further in the text).</p><p>Several years ago, certain scientists developed a way of investigating the nature of the atmosphere of the past by studying air caught in the ice around the North or South Pole. According to their theory, when snow falls, air is trapped between the snowflakes. The snow turns to ice with the air still inside. Certain scientists claimed that 1) atmospheric gases increase the yearly amount of snow 2) falling snowflakes change the chemical balance of the air 3) the action of atmospheric gases causes snow to turn into ice 4) the air held between snowflakes keeps its original nature (correct)</p><p>In the following passage/question pair, our system picked the answer choice 3. It would have been easy to pick the correct answer 1 if "wrong" could have been linked to "mistake", but in ConceptNet, this is a RelatedTo relation, which we did not consider. We realize that there is actually a lot of information in those RelatedTo relations, and ideally our system should handle them, but we decided in the design phase to remove them because they are not semantically precise. Everyone stared. That was embarrassing enough, but it was worse when I finished my coffee and got ready to leave. My face went red -as red as his hair -when I realized I'd made a mistake. The woman's face turned red 1) because she realized that she had been quite wrong about the boy (correct) 2) because she realized that the boy was poor and hungry 3) because she saw everyone staring at her 4) because she hated being shouted at In both those cases, a more precise characterization of correct passages would have been useful, because in the first case, our answer choice skips over the sentence which contains the correct answer, and in the second case, the sentence containing our answer choice appears way before the sentence containing both question and correct answer. Finally we report an example of correctly answered question through mostly invalidation. In the following passage/question pair, our system frankly invalidated answer choice 1 (due to the added negation) and answer choice 4 (due to the first sentence of the passage saying the opposite). Then, answer choice 2 had edit sequences which hinted at both validation and invalidation, so it was still a risky pick (but with slightly more invalidation). In the end, the remaining answer choice (3), for which the system found neither validation nor invalidation, was correctly picked by default.</p><p>Kate was an energetic woman who expected people always to be doing something, and she found plenty of jobs for Fred to do. This made him feel part of the household, but now he really wanted to be able to sit and reflect on the events of his life. If he had continued to live alone, he would have had the time to do this to his heart's content. One afternoon he felt he simply had to get away from the house. "I'm going for a walk," he said, closing the door behind him. Leaving the town, he walked across the fields and followed a slow-moving stream toward the hills. After a while he came to a pool in the stream under some trees. Here, he thought, was a place he could come to when he needed to reflect on the past. Although the stream seemed unlikely to have any fish, he would simply tell Kate he had found a place to go fishing. When he mentioned the stream that night, his son-in-law, Jim, said in disbelief, "There aren't any fish there. That stream runs dry half the summer." Why did Fred tell Kate that he had found a place to go fishing? 1) He didn't feel part of the household with Kate and Jim.</p><p>2) He enjoyed fishing very much and was glad to be able to do it again.</p><p>3) He wanted a way to leave the house without hurting Kate's feelings. 4) He was bored in the house because there were few things to do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Quantitative analysis</head><p>The general trend was that our system performed better when edit sequences remained short, with over 40% accuracy when the chosen edit sequences are shorter than 6 edits (on average on all the answer choices). We considered this was still not significant enough of an advantage to choose not to answer questions based on a length threshold of edit sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Future work</head><p>We did not take advantage of the possibility to choose not to answer a question. In our experience, every missed answer adds variance when running on the test set (we are evaluated on even fewer questions, when there are not many to begin with), so we did not prioritize exploiting this feature of the evaluation. However, we believe our learning method has the potential to handle it. In future works, it would be interesting to design a meta-classifier working on the output of the two current classifiers.</p><p>Our system has been developed to answer multiple-choice questions. We extract features from edit sequences obtained from our tree edit beam search method, and learn two classifiers for validation and invalidation of answer choices. In the CLEF 2015 evaluation campaign, Question Answering track, Entrance Exams task, our best submitted run obtained the second performance among teams. In further works, we plan to improve our graph enrichment method, which seems to be a promising avenue. We are considering adding paraphrases to the graph. Moreover, we plan to develop a meta-classifier dealing with the final decision, based on the individual validation/invalidation scores per answer choice, instead of relying on manually crafted rules.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="2,251.06,458.44,113.23,7.89"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. System Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="9,218.71,356.25,177.95,7.89"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Semantics of (passage, answer) pairs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="5,136.56,116.91,342.95,60.94"><head>Table 1 .</head><label>1</label><figDesc>Edit operations on trees</figDesc><table coords="5,136.56,136.71,342.95,41.14"><row><cell>Edit operation</cell><cell>Description</cell></row><row><cell>Delete(d: Tree)</cell><cell>Delete the node d and replace it with its children.</cell></row><row><cell>Insert(i: Word, p: Tree)</cell><cell>Insert the word i under its new parent p.</cell></row><row><cell>Rename(t: Tree, w: Word)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="7,136.56,171.27,342.24,436.33"><head>Table 2 .</head><label>2</label><figDesc>Features of an edit sequence</figDesc><table coords="7,136.56,191.08,342.24,416.53"><row><cell>Feature</cell><cell>Description</cell></row><row><cell>editTotal</cell><cell>Total number of edits in the sequence</cell></row><row><cell>deleteTotal</cell><cell>Number of total delete edits, edits which delete</cell></row><row><cell>deleteVerb</cell><cell>a verb, a noun, a proper noun, a subject (indi-</cell></row><row><cell>deleteNoun</cell><cell>cated by the subj Stanford dependencies), an</cell></row><row><cell>deleteProperNoun</cell><cell>object, the root of the tree, a negation (indi-</cell></row><row><cell>deleteSubject</cell><cell>cated by the neg dependency), and something</cell></row><row><cell>deleteObject</cell><cell>added to the graph through ConceptNet</cell></row><row><cell>deleteRoot</cell><cell></cell></row><row><cell>deleteNegation</cell><cell></cell></row><row><cell>deleteConceptNet</cell><cell></cell></row><row><cell>insertTotal</cell><cell>Analogous to the above, for insert edits</cell></row><row><cell>insertVerb</cell><cell></cell></row><row><cell>insertNoun</cell><cell></cell></row><row><cell>insertProperNoun</cell><cell></cell></row><row><cell>insertNegation</cell><cell></cell></row><row><cell>renameTotal</cell><cell>Analogous to the above, for rename edits + ed-</cell></row><row><cell>renameVerb</cell><cell>its which rename a word into its synonym in</cell></row><row><cell>...</cell><cell>WordNet, or into its antonym in WordNet, or</cell></row><row><cell>renameSyn</cell><cell>into a hypernym/hyponym in Wordnet, edits</cell></row><row><cell>renameAnt</cell><cell>which rename a word into another with strong</cell></row><row><cell>renameHypHyp</cell><cell>word vector similarity (above a threshold, de-</cell></row><row><cell>renameStrongWordVectorSim</cell><cell>fined empirically), edits which rename a pro-</cell></row><row><cell>renameCoref</cell><cell>noun into its referent according to the Stanford</cell></row><row><cell>renameNonCoref</cell><cell>coreference resolution, and edits which rename</cell></row><row><cell></cell><cell>a pronoun into some other referent</cell></row><row><cell>moveTotal</cell><cell>Analogous to the above, for move edits + edits</cell></row><row><cell>moveVerb</cell><cell>which move more than 2 nodes</cell></row><row><cell>...</cell><cell></cell></row><row><cell>moveConceptNet</cell><cell></cell></row><row><cell>moveMoreThan2Nodes</cell><cell></cell></row><row><cell cols="2">All bigram combinations of the above Number of pairs of the successive given edits in</cell></row><row><cell></cell><cell>the sequence</cell></row><row><cell>dependencyEditSequence</cell><cell>Number of pairs of successive edits applied to</cell></row><row><cell></cell><cell>2 nodes in a dependency relation</cell></row><row><cell>originalTotal</cell><cell>Fraction of the original words, verbs, nouns,</cell></row><row><cell>originalVerb</cell><cell>proper nouns, that was not edited in the se-</cell></row><row><cell>...</cell><cell>quence</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="9,198.16,526.04,219.04,92.07"><head>Table 3 .</head><label>3</label><figDesc>Results on test</figDesc><table coords="9,198.16,544.10,219.04,74.02"><row><cell></cell><cell cols="2">Random forest Logistic regression</cell></row><row><cell>Questions answered</cell><cell>89</cell><cell>89</cell></row><row><cell>Errors</cell><cell>57</cell><cell>61</cell></row><row><cell>Accuracy</cell><cell>0.360</cell><cell>0.314</cell></row><row><cell># of tests</cell><cell>8</cell><cell>4</cell></row><row><cell>with c@1 ≥ 0.5</cell><cell></cell><cell></cell></row><row><cell>c@1</cell><cell>0.360</cell><cell>0.314</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="12,138.35,306.97,342.24,7.86;12,146.91,317.93,333.68,7.86;12,146.91,328.89,333.68,7.86;12,146.91,339.85,333.68,7.86;12,146.91,350.81,317.66,7.86" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="12,235.22,306.97,245.37,7.86;12,146.91,317.93,19.07,7.86">A hierarchical taxonomy for classifying hardness of inference tasks</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Gleize</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Grau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,376.81,328.89,103.79,7.86;12,146.91,339.85,333.68,7.86;12,146.91,350.81,186.26,7.86">Proceedings of the Ninth International Conference on Language Resources and Evaluation (LREC&apos;14). European Language Resources Association (ELRA)</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Chair</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><forename type="middle">C C</forename><surname>Choukri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Declerck</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Loftsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Maegaard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Mariani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Moreno</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Odijk</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Piperidis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename></persName>
		</editor>
		<meeting>the Ninth International Conference on Language Resources and Evaluation (LREC&apos;14). European Language Resources Association (ELRA)<address><addrLine>Reykjavik, Iceland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,361.77,342.24,7.86;12,146.91,372.73,333.68,7.86;12,146.91,383.68,51.70,7.86" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="12,464.72,361.77,15.88,7.86;12,146.91,372.73,146.81,7.86">The weka data mining software: an update</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">E</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">G</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Pfahringer</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Reutemann</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">I</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,300.13,372.73,154.85,7.86">ACM SIGKDD explorations newsletter</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="10" to="18" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,394.64,342.24,7.86;12,146.91,405.60,333.68,7.86;12,146.91,416.56,333.67,7.86;12,146.91,427.52,252.49,7.86" xml:id="b2">
	<analytic>
		<title level="a" type="main" coord="12,353.62,394.64,126.97,7.86;12,146.91,405.60,188.90,7.86">Improving word representations via global context and multiple word prototypes</title>
		<author>
			<persName coords=""><forename type="first">E</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,355.69,405.60,124.90,7.86;12,146.91,416.56,290.58,7.86">Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers</title>
		<meeting>the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="873" to="882" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,438.48,342.24,7.86;12,146.91,449.44,333.68,7.86;12,146.91,460.40,236.63,7.86" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="12,258.35,438.48,123.26,7.86">Accurate unlexicalized parsing</title>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,404.44,438.48,76.15,7.86;12,146.91,449.44,276.91,7.86">Proceedings of the 41st Annual Meeting on Association for Computational Linguistics</title>
		<meeting>the 41st Annual Meeting on Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="423" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,471.36,342.24,7.86;12,146.91,482.31,148.49,7.86" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="12,221.42,471.36,217.30,7.86">Conceptneta practical commonsense reasoning tool-kit</title>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,445.00,471.36,35.59,7.86;12,146.91,482.31,57.88,7.86">BT technology journal</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="211" to="226" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,493.27,342.24,7.86;12,146.91,504.23,287.23,7.86" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="12,203.93,493.27,276.66,7.86;12,146.91,504.23,17.99,7.86">Efficient convolution kernels for dependency and constituent syntactic trees</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Moschitti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,185.64,504.23,124.97,7.86">Machine Learning: ECML 2006</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="318" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,515.19,342.24,7.86;12,146.91,526.15,333.67,7.86;12,146.91,537.11,333.68,7.86;12,146.91,548.07,174.77,7.86" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="12,330.87,515.19,149.72,7.86;12,146.91,526.15,140.30,7.86">The life and death of discourse entities: Identifying singleton mentions</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Recasens</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">C</forename><surname>De Marneffe</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,309.22,526.15,171.37,7.86;12,146.91,537.11,333.68,7.86;12,146.91,548.07,90.80,7.86">Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="627" to="633" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,556.76,342.25,10.13;12,146.91,569.99,333.68,7.86;12,146.91,580.94,25.60,7.86" xml:id="b7">
	<monogr>
		<title level="m" type="main" coord="12,214.00,569.99,169.69,7.86">Overview of qa4mre main task at clef 2013</title>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Sutcliffe</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Peñas</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Forner</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Á</forename><surname>Rodrigo</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Forascu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Y</forename><surname>Benajiba</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Osenova</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>CLEF</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Working Notes</note>
</biblStruct>

<biblStruct coords="12,138.35,591.90,342.24,7.86;12,146.91,602.86,333.68,7.86;12,146.91,613.82,333.67,7.86;12,146.91,624.78,333.68,7.86;12,146.91,635.74,98.02,7.86" xml:id="b8">
	<analytic>
		<title level="a" type="main" coord="12,371.39,591.90,109.20,7.86;12,146.91,602.86,167.97,7.86">Feature-rich part-of-speech tagging with a cyclic dependency network</title>
		<author>
			<persName coords=""><forename type="first">K</forename><surname>Toutanova</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,336.65,602.86,143.94,7.86;12,146.91,613.82,333.67,7.86;12,146.91,624.78,132.25,7.86">Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology</title>
		<meeting>the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="173" to="180" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
