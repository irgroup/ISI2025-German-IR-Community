<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,114.34,148.91,374.31,15.49">UNGRADE:UNsupervised GRAph DEcomposition</title>
				<funder ref="#_TBFa2n5">
					<orgName type="full">EPSRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,200.44,182.75,57.18,8.97"><forename type="first">Bruno</forename><surname>Golénia</surname></persName>
							<email>goleniab@cs.bris.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="laboratory">Machine Learning Group</orgName>
								<orgName type="institution">University of Bristol</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,264.36,182.75,73.74,8.97"><forename type="first">Sebastian</forename><surname>Spiegler</surname></persName>
							<email>spiegler@cs.bris.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="laboratory">Machine Learning Group</orgName>
								<orgName type="institution">University of Bristol</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,357.46,182.75,45.10,8.97"><forename type="first">Peter</forename><surname>Flach</surname></persName>
							<email>flach@cs.bris.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="laboratory">Machine Learning Group</orgName>
								<orgName type="institution">University of Bristol</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,114.34,148.91,374.31,15.49">UNGRADE:UNsupervised GRAph DEcomposition</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5BAFFDD8B85F3C3C303DF07662D67F91</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.2 [ARTIFICIAL INTELLIGENCE]: H.3.1 Learning</term>
					<term>I.2.7 Natural Language Processing</term>
					<term>I.2.8 Graph and tree search strategies Algorithms, Performance, Experimentation MDL, Unsupervised learning, Word morphology, Word decomposition, Stopping criterion</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article presents an unsupervised algorithm for word decomposition called UNGRADE (UNsupervised GRAph DEcomposition) to segment any word list of any language. UNGRADE assumes that each word follows the structure prefixes, a stem and suffixes without giving a limit on the number of prefixes and suffixes. The UNGRADE's algorithm works in three steps and is language independent. Firstly, a pseudo stem is found for each word using a window based on Minimum Description Length. Secondly, prefix sequences and suffix sequences are found independently using a graph algorithm called graphbased unsupervised sequence segmentation. Finally, the morphemes from previous steps are joined to provide a segmented word list. We focus purely on the segmentation of words, thus, we employ a trivial method for labeling each morpheme which is the segment of the morpheme itself. UNGRADE is applied to 5 languages (English, German, Finnish, Turkish and Arabic) and results are provided according to their gold standard.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Morphological analysis is concerned with the process of segmenting a given corpus of words into a set of morphemes. Morphemes are the smallest units bearing a meaning in a word. In a corpus, the quantity of different morphemes is usually smaller than the quantity of different words. The purpose of the Morpho Challenge is to learn these morphemes using an unsupervised algorithm on different languages. Such a morphological analyser is useful for various applications like speech synthesis, information retrieval or machine translation where a dictionary of morphemes must be provided. Indeed, creating a dictionary of morphemes for a speech synthesis application cannot be directly carried out from raw data on all languages. The reason is that for languages like Turkish, there are many possible combinations of morphemes, therefore the number of words becomes too large to be used naively as a dictionary in a application. Basically, using millions of words as a dictionary instead of set of morphemes is not feasible. The development of a such morphological analyser to segment words can be realised by linguistic experts or with a machine. Unfortunately, linguistic experts are rare and an expensive resource for some languages such as Zulu. As a result, it is worth to study machine learning approaches to reduce the quantity of work needed to create a vocabulary of morphemes by linguistic experts. In the past, research in computational linguistics mainly focused on unsupervised morphological analysis for large datasets with approaches like Linguistica <ref type="bibr" coords="2,484.83,112.02,11.62,8.97" target="#b8">[9]</ref> and Morfessor <ref type="bibr" coords="2,133.80,123.98,10.58,8.97" target="#b3">[4]</ref>. Recently, Shalonova et al. <ref type="bibr" coords="2,260.70,123.98,16.60,8.97" target="#b13">[14]</ref> have introduced an efficient semi-supervised approach for small data sets. Afterwards, Spiegler et al. compared the approach with Morfessor <ref type="bibr" coords="2,423.61,135.93,15.27,8.97" target="#b14">[15]</ref>. In this paper, we extend the semi-supervised approach for large data sets and make it unsupervised through a pre-process based on a window. We make the assumption that each word for any language has prefixes, a stem and suffixes. We do not restrict the number of prefixes and suffixes for our algorithm. We decide to label morphemes by their segment and not their grammatical categories. The method that we propose can be broken down into three phases and be processed to any unlabeled corpora. The first step consists of identifying the stem in each word, we propose the utilisation of a window with Minimum Description Length (MDL) to cover the problem. In second step for finding sequences of prefixes and suffixes, we apply an unsupervised algorithm which has been simplified for large datasets. Finally, in last step we aggregate the results from the first and the second step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Stem extraction using a window of letters</head><p>Extraction of morpheme sequences are a hard task in languages where the word form includes sequences of prefixes, stem and sequences of suffixes. However, by finding the boundaries of the stem first, it is possible to extract prefix sequences and suffix sequences efficiently. In order to extract the stems, we look for a pseudo stem in the middle of each word, which is most often a position overlapping the real stem. We develop a heuristic to seek the most probable stem given a word through a window by using the MDL principle. We define a window by two boundaries within a word between letters. In other words, a window is a sub string of a word. During initialisation, the width of the window is defined as a letter in the middle of a word. Thereafter, an algorithm is used to shift or increase the width of the window from its initial point to its left and/or to its right side. Consequently, an evaluation function is used for each window and repeated for the best windows up to no better windows are found. The final boundaries are considered as the limit of the stem in the word. We iterate the algorithm for each word in the corpus, the evaluation function used is the MDL window score. Definition 1. Let win = (l win , u win ) be a window with a lower boundary l win and an upper boundary u win . Given a word w and a window win the MDL window score is defined by: MDL Window Score(win, w) = log 2 (u win -l win + 1) + log 2 (np sub string(w, l win , u win ))</p><p>where np sub string denotes the n-gram probability of the window win in the word w.</p><p>As soon as the algorithm has been applied to each word from a corpus, we process the left side of each window to extract the prefixes. In a similar way, we process the right side of the window to extract the suffixes. To do so, we use an extension of the GBUSS algorithm presented in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Graph-Based Unsupervised Morpheme Segmentation</head><p>The algorithm GBUSS (Graph-Based Unsupervised Suffix Segmentation) was developed in <ref type="bibr" coords="2,456.86,606.37,16.60,8.97" target="#b9">[10]</ref> to extract suffix sequences efficiently and applied for Russian and Turkish languages on a training set in <ref type="bibr" coords="2,478.17,618.32,15.77,8.97" target="#b9">[10,</ref><ref type="bibr" coords="2,497.23,618.32,11.83,8.97" target="#b13">14]</ref>. Afterwards, we use GBUSS to extract independently both prefix and suffix sequences, instead of only suffix sequences. We refer to prefixes and suffixes generally as morpheme. We call L-corpus (R-corpus) the list of words obtained from the left-side (right-side) of the windows. In an independent manner, we use the term M-corpus for a L-corpus (R-corpus) in a prefix (suffix) graph-based context. We call GBUMS (Graph-Based Unsupervised Morpheme Segmentation) the extended version of the GBUSS algorithm for morpheme extraction. Moreover, we present one improvement from GBUSS, a simplified evaluation function for merging nodes which replace FPPEdgeL (An evaluation measure for context score and suffix frequency adapted from Yoshida et al. <ref type="bibr" coords="2,247.51,713.96,14.94,8.97" target="#b15">[16]</ref>). In this section, we describe GBUMS to extract sequence of morphemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Morpheme graph for agglomerative morpheme extraction</head><p>GBUMS uses a morpheme graph in a bottom-up fashion. Similar to Harris <ref type="bibr" coords="3,399.69,130.70,15.27,8.97" target="#b10">[11]</ref>, we base our algorithm on letter frequencies. However, where Harris builds on successor and predecessor frequencies, we use position-independent n-gram statistics to merge single letters to morphemes until a stopping criterion has been met. In the morpheme graph, each node represents a morpheme and each directed edge the concatenation of two morphemes labeled with the frequencies in a M-corpus. Definition 2. Let M = {m i |1 ≤ i ≤ n} be a set of morphemes, let f i be the frequency with which morpheme m i occurs in a M-corpus X of morpheme sequences, let v i = (m i , f i ) for 1 ≤ i ≤ n, and let f i, j denote the number of morpheme sequences in the corpus in which morpheme m i is followed by morpheme m j . The morpheme graph G = (V, E) is a directed graph with vertices or nodes V = {v i |1 ≤ i ≤ k} and edges E = {(v i , v j )| f i, j &gt; 0}. We treat f i, j as the label of the edge from v i to v j .</p><p>In G, each node is initialised with a letter according to a M-corpus X, then, step by step nodes are merged to create the real morphemes. To merge nodes an evaluation function is necessary. In <ref type="bibr" coords="3,493.91,278.15,15.27,8.97" target="#b13">[14]</ref>, Shalonova et al. proposed one based on frequency and entropy. For large data sets, due to high computational costs we simplify the equation and do not take in account the entropy. Moreover, a pair (m 1 , m 2 ) adequate for merging was characterised by the following constraints:</p><p>• low frequency for the individual morphemes m 1 and m 2</p><p>• high frequency of the concatenation</p><formula xml:id="formula_1" coords="3,104.94,353.86,183.40,29.82">m 1 • m 2 • short sequences m 1 • m 2</formula><p>The approach that we present does not take in consideration the last constraint and can be viewed as the lift of a rule for association rules in data mining <ref type="bibr" coords="3,295.87,405.67,10.58,8.97" target="#b2">[3]</ref>. Consequently, we name the evaluation function Morph Lift. Definition 3. Morph Li f t is defined for a pair of morphemes m 1 and m 2 as follows:</p><formula xml:id="formula_2" coords="3,238.43,457.28,274.57,23.54">Morph Li f t(m 1 , m 2 ) = f 1,2 f 1 + f 2<label>(2)</label></formula><p>From now on, we know how to merge nodes. Now, we need to figure out the most important part of GBUMS which is the stopping criterion. The stopping criterion is to prevent over-generalisation. In other words, we need to stop the algorithm before getting the initial M-corpus (since no merging is possible). Four stopping criteria have been presented in <ref type="bibr" coords="3,279.52,526.63,16.60,8.97" target="#b13">[14]</ref> to treat this issue. Only the most efficient has been utilised in this article. The criterion comes from <ref type="bibr" coords="3,285.18,538.59,15.27,8.97" target="#b11">[12]</ref>. This criterion is based on the Bayesian information Criterion (BIC) and Jensen-Shannon divergence. The latter is defined as follows <ref type="bibr" coords="3,411.84,550.54,10.79,8.97" target="#b4">[5]</ref>: Definition 4. The Jensen-Shannon divergence is defined for two morphemes m 1 and m 2 as the decrease in entropy between the concatenated and the individual morphemes:</p><formula xml:id="formula_3" coords="3,195.21,602.91,313.92,22.60">D JS (m 1 , m 2 ) = H(m 1 • m 2 ) - L m 1 H(m 1 ) + L m 2 H(m 2 ) N (<label>3</label></formula><formula xml:id="formula_4" coords="3,509.13,609.70,3.87,8.97">)</formula><p>where H(m) = -P(m) log 2 P(m), N = ∑ m Freq(m) and L m is the string length of m.</p><p>Stopping criterion SC1 requires that ∆BIC &lt; 0 which translates to:</p><formula xml:id="formula_5" coords="3,249.22,680.97,263.78,15.61">max s 1 ,s 2 D JS (s 1 , s 2 ) ≤ 2 log 2 N (4)</formula><p>We stress that the BIC is equal to MDL except that the BIC sign is opposite <ref type="bibr" coords="3,400.93,707.24,10.58,8.97" target="#b7">[8]</ref>. To sum up, the GBUMS (Algorithm 1) follows these steps:</p><p>1. build a morpheme graph from all one-letter morphemes.</p><p>Note that the execution of GBUMS for L-corpus and R-corpus can be processed in parallel to reduce significantly the running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related work</head><p>Much research on Unsupervised segmentation of morphology has focused on statistical approaches according to the work of Harris <ref type="bibr" coords="5,191.02,191.82,15.77,8.97" target="#b10">[11,</ref><ref type="bibr" coords="5,209.27,191.82,8.30,8.97" target="#b5">6]</ref> and tuning of parameters according to a language like Gaussier <ref type="bibr" coords="5,473.68,191.82,10.58,8.97" target="#b6">[7]</ref>. <ref type="bibr" coords="5,490.86,191.82,22.14,8.97;5,90.00,203.78,26.56,8.97" target="#b0">Brent (1993)</ref> presented the MDL theory for Computational linguistic problems with a probabilistic approach using the spelling of words <ref type="bibr" coords="5,204.92,215.73,10.58,8.97" target="#b0">[1]</ref>. Afterwards, <ref type="bibr" coords="5,275.73,215.73,52.11,8.97" target="#b1">Brent (1995)</ref> defined an approach for finding suffixes in a language <ref type="bibr" coords="5,128.62,227.69,10.58,8.97" target="#b1">[2]</ref>. Unfortunately, Brent's approach required a special tagging of the data. Subsequently, Goldsmith (2001) used MDL <ref type="bibr" coords="5,191.89,239.64,11.62,8.97" target="#b8">[9]</ref> to combine the results of multiple heuristics based on statistic like <ref type="bibr" coords="5,479.76,239.64,10.79,8.97" target="#b5">[6,</ref><ref type="bibr" coords="5,493.75,239.64,8.30,8.97" target="#b6">7]</ref> in a software called Linguistica. Goldsmith defined a model for MDL with signature. However, Linguistica was only focused on European languages. More recently, Creutz et al. <ref type="bibr" coords="5,369.06,263.55,11.62,8.97" target="#b3">[4]</ref> (2002) presented Morfessor with two new approaches to discover morphemes named Morfessor baseline and Morfessor Categories-MAP. The former method was based on MDL in a recursive method. The latter one, the most efficient, combined Maximum Likelihood and Viterbi for an optimal segmentation. Morfessor was developed independently of languages and provided good results. Lately, Paramor (2007) developed by Monson, in a similar way to Goldsmith with signatures used paradigm without using MDL. Paramor worked in two steps and provided results as good as Morfessor. In 2008, Results from Paramor and Morfessor were combined and provided better results than one of them alone <ref type="bibr" coords="5,237.47,347.24,15.27,8.97" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Processing and results</head><p>In order to test UNGRADE, we used the Morpho Challenge data sets of 2009 which contains English (384903 words), German (1266159 words), Finnish (2206719 words), Turkish (617298 words), Arabic non-vowelized (14957 words) and Arabic vowelized (19244 words). Before running UNGRADE on the different data sets, we decided to use a pre-processing algorithm to remove marginal words and potential noise. To do so, we analysed the word length distribution to remove infrequent short and long words. We came up to the following length range for each data set (Table <ref type="table" coords="5,341.50,462.90,3.60,8.97" target="#tab_0">1</ref>). Therefore, we used smaller data sets as input to UNGRADE. After running UNGRADE, in order to segment the remaining words of the original data sets, we used a segmented corpus from the output of UNGRADE as a model of segmentation. Thus, we applied this model to each word not present in the input data set of UNGRADE. The evaluation measure used is the F-measure which is the harmonic mean between the Precision and the Recall.</p><formula xml:id="formula_6" coords="5,228.42,530.65,280.71,22.55">F -measure = 2 • Precision • Recall Precision + Recall (<label>5</label></formula><formula xml:id="formula_7" coords="5,509.13,537.39,3.87,8.97">)</formula><p>The precision is computed as follows: A sample of words is randomly chosen from the result file. Then, a pair of words is defined for each morpheme of each word in the sample randomly by a word sharing the same morpheme from the result file. Finally, each pair of words is compared to the same pair in the gold standard to check if they have the same morphemes in common.</p><p>Similarly, the recall is calculated except that the sampling and the pairs are defined using the gold standard. Also, the checking of morphemes is carried out on the result file and not on the gold standard. We stress that the morphemes labels that we use are the spelling of the morphemes and not their grammatical categories. The final results used a linguistic morpheme analysis gold standard and are showed on (Figure <ref type="figure" coords="5,121.82,654.45,4.98,8.97" target="#fig_0">1</ref> and Table <ref type="table" coords="5,170.55,654.45,3.60,8.97" target="#tab_1">2</ref>). The F-measure for German, English, Turkish and Finnish are of the same order of magnitude (between 33.44% and 37.11%). Surprisingly, Arabic non-vowelized provided the worst (26.78%) and Arabic vowelized the best (54.36%) F-measure among all languages. The divergence in F-measure for Arabic is explained by the average word length. For Arabic, the non-vowelized words are almost on average twice shorter for the same amount of morphemes on average. We can note that the precision is higher than recall for all data sets except English. The low level of precision in English is due to the low morpheme number distribution on average. This observation is confirmed in Arabic (vowelized) where the morpheme number distribution on average is higher and therefore gives a high precision. It is interesting to remark that even if the starting point to look for a pseudo stem of the UNGRADE algorithm is less correct for Turkish (Turkish does not have prefixes), the results are quite competitive with Finnish. To sum up, UNGRADE is more efficient for a language with long words on average and a high number of morphemes by word on average. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and future directions</head><p>An unsupervised three-step algorithm for word segmentation UNGRADE has been presented. UNGRADE is defined on the general assumption on the structure of words for languages that each word contains prefixes, a stem and suffixes. UNGRADE uses a basic labeling of the morphemes which is by their segment. Results on the Morpho Challenge 2009 for 5 languages (English, German, Turkish, Finnish, Arabic vowelized and Arabic non-vowelized) show encouraging payoff for this simple algorithm on all languages. Results point out that UNGRADE performs on average with 35.92% of F-measure for English, German, Turkish and Finnish. Particularly, outcomes demonstrate that UNGRADE work well on Arabic vowelized with more than 54% of F-measure. UNGRADE illustrate high performance for languages with long words including a high number of morphemes. An important future work should use different starting points for looking to the pseudo stem at for instance the beginning of the word, the end of the word, etc. Afterwards, a committee could choose the best segmentation under some MDL criterion which may improve significantly the results. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="7,198.95,407.44,205.10,8.97"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Results from the Morpho Challenge 2009</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="6,172.72,178.75,255.07,95.01"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table coords="6,172.72,178.75,255.07,95.01"><row><cell cols="2">Pre-processing of data sets</cell><cell></cell></row><row><cell>Language</cell><cell cols="2">Minimum length Maximum length</cell></row><row><cell>English</cell><cell>3</cell><cell>13</cell></row><row><cell>German</cell><cell>5</cell><cell>18</cell></row><row><cell>Finnish</cell><cell>5</cell><cell>25</cell></row><row><cell>Turkish</cell><cell>5</cell><cell>16</cell></row><row><cell>Arabic (non-vowelized)</cell><cell>2</cell><cell>9</cell></row><row><cell>Arabic (vowelized)</cell><cell>3</cell><cell>18</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="6,181.98,319.41,236.55,95.01"><head>Table 2 :</head><label>2</label><figDesc>Results from the Morpho Challenge 2009</figDesc><table coords="6,181.98,331.33,236.55,83.09"><row><cell>Language</cell><cell cols="3">Precision Recall F-Measure</cell></row><row><cell>English</cell><cell>.2829</cell><cell>.5389</cell><cell>.3711</cell></row><row><cell>German</cell><cell>.3902</cell><cell>.2925</cell><cell>.3344</cell></row><row><cell>Finnish</cell><cell>.4078</cell><cell>.3305</cell><cell>.3651</cell></row><row><cell>Turkish</cell><cell>.4667</cell><cell>.3016</cell><cell>.3664</cell></row><row><cell>Arabic (non-vowelized)</cell><cell>.8348</cell><cell>.1595</cell><cell>.2678</cell></row><row><cell>Arabic (vowelized)</cell><cell>.7215</cell><cell>.4361</cell><cell>.5436</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We would like to thank our team colleagues <rs type="person">Roger Tucker</rs> and <rs type="person">Ksenia Shalonova</rs> for consultations on general morphological analysis. The work was sponsored by <rs type="funder">EPSRC</rs> grant <rs type="grantNumber">EP/E010857/1</rs> Learning the morphology of complex synthetic languages.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_TBFa2n5">
					<idno type="grant-number">EP/E010857/1</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Note that the M-Corpus is completely segmented at the beginning of the algorithm. Then, the boundaries in the segmented M-Corpus are removed step by step according to a pair found in the graph with the maximum value for Morph Li f t. Since, the stopping criterion is violated the segmented M-Corpus represents the sequence morphemes. In this section, we have presented a method to extract sequences of prefixes and sequences of suffixes. In the next section, we show the final step and the full algorithm to obtain a segmented corpus from raw words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">UNsupervised GRAph DEcomposition</head><p>In previous sections, we showed how to find prefix sequences, pseudo stem and suffix sequences without linking them. The final step of the segmentation algorithm is straightforward, it is made up of the aggregation (concatenation) of the sequence of prefixes, pseudo stem and sequence of suffixes found with the MDL Window and GBUMS for each word. The complete algorithm called UNGRADE (UNsupervised GRAph DEcomposition) including all phases is summarized in (Algorithm 2). </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct coords="7,111.58,461.75,401.42,8.97;7,111.58,473.71,289.51,8.97" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="7,168.08,461.75,306.90,8.97">Minimal generative models: A middle ground between neurons and triggers</title>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">R</forename><surname>Brent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,495.29,461.75,17.71,8.97;7,111.58,473.71,205.63,8.97">15th Annual Conference of the Cognitive Science Society</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="28" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,493.63,401.42,8.97;7,111.58,505.59,401.42,8.97;7,111.58,517.54,62.27,8.97" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="7,378.97,493.63,134.03,8.97;7,111.58,505.59,131.50,8.97">Discovering Morphemic Suffixes A Case Study In MDL Induction</title>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Sreerama</forename><forename type="middle">K</forename><surname>Brent</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Andrew</forename><surname>Murthy</surname></persName>
		</author>
		<author>
			<persName coords=""><surname>Lundberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,274.59,505.59,198.46,8.97">Fifth International Workshop on AI and Statistics</title>
		<meeting><address><addrLine>Ft</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="264" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,537.47,401.42,8.97;7,111.58,549.42,401.42,8.97;7,111.58,561.38,348.64,8.97" xml:id="b2">
	<analytic>
		<title level="a" type="main" coord="7,315.52,537.47,197.48,8.97;7,111.58,549.42,91.08,8.97">Dynamic itemset counting and implication rules for market basket data</title>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Tsur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,226.17,549.42,286.83,8.97;7,111.58,561.38,138.99,8.97">SIGMOD &apos;97: Proceedings of the 1997 ACM SIGMOD international conference on Management of data</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="255" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,581.30,401.42,8.97;7,111.58,593.26,401.42,8.97;7,111.58,605.21,172.13,8.97" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="7,221.69,581.30,156.29,8.97">Unsupervised discovery of morphemes</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Creutz</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">K</forename><surname>Lagus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,401.77,581.30,111.23,8.97;7,111.58,593.26,222.28,8.97">Proceedings of the ACL-02 workshop on Morphological and phonological learning</title>
		<meeting>the ACL-02 workshop on Morphological and phonological learning<address><addrLine>Morristown, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,625.14,401.42,8.97;7,111.58,637.10,401.42,8.97;7,111.58,649.05,401.43,8.97;7,111.58,661.01,52.31,8.97" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="7,248.31,625.14,237.02,8.97">Similarity-Based Methods for Word Sense Disambiguation</title>
		<author>
			<persName coords=""><forename type="first">I</forename><surname>Dagan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">L</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">F</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,495.19,625.14,17.81,8.97;7,111.58,637.10,401.42,8.97;7,111.58,649.05,372.27,8.97">Proceedings of the Thirty-Fifth Annual Meeting of the Association for Computational Linguistics and Eighth Conference of the European Chapter of the Association for Computational Linguistics</title>
		<meeting>the Thirty-Fifth Annual Meeting of the Association for Computational Linguistics and Eighth Conference of the European Chapter of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="56" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,680.93,401.42,8.97;7,111.58,692.89,22.42,8.97" xml:id="b5">
	<monogr>
		<title level="m" type="main" coord="7,163.33,680.93,345.28,8.97">Morphemes as Necessary Concept for Structures Discovery from Untagged Corpora</title>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Déjean</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="7,111.58,712.81,401.42,8.97;7,111.58,724.77,366.75,8.97" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="7,162.13,712.81,315.11,8.97">Unsupervised Learning of Derivational Morphology From Inflectional Lexicons</title>
		<author>
			<persName coords=""><forename type="first">E</forename><surname>Gaussier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="7,495.03,712.81,17.97,8.97;7,111.58,724.77,337.64,8.97">ACL &apos;99 Workshop Proceedings: Unsupervised Learning in Natural Language Processing</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,112.02,401.42,8.97;8,111.58,123.98,401.42,8.97;8,111.58,135.93,296.84,8.97" xml:id="b7">
	<analytic>
		<title level="a" type="main" coord="8,194.16,112.02,318.84,8.97;8,111.58,123.98,115.63,8.97">A Bayesian Information Criterion Based Approach for Model Complexity Selection in Speaker Identification</title>
		<author>
			<persName coords=""><forename type="first">Y</forename><surname>Geng</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="8,246.70,123.98,262.00,8.97;8,136.49,135.93,158.75,8.97">Advanced Language Processing and Web Information Technology</title>
		<imprint>
			<date type="published" when="2008-07">2008. July 2008</date>
			<biblScope unit="page" from="264" to="268" />
		</imprint>
	</monogr>
	<note>ALPIT &apos;08. International Conference on</note>
</biblStruct>

<biblStruct coords="8,111.58,155.86,401.42,8.97;8,111.58,167.81,123.72,8.97" xml:id="b8">
	<analytic>
		<title level="a" type="main" coord="8,172.87,155.86,268.85,8.97">Unsupervised Learning of the Morphology of a Natural Language</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Goldsmith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="8,453.22,155.86,59.79,8.97;8,111.58,167.81,42.37,8.97">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="153" to="198" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,187.74,401.42,8.97;8,111.58,199.69,66.36,8.97" xml:id="b9">
	<monogr>
		<title level="m" type="main" coord="8,159.14,187.74,242.02,8.97">Learning rules in morphology of complex synthetic languages</title>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Golénia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>University of Paris V</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct coords="8,111.58,219.62,296.98,8.97" xml:id="b10">
	<analytic>
		<title level="a" type="main" coord="8,153.62,219.62,114.96,8.97">From Phoneme to Morpheme</title>
		<author>
			<persName coords=""><forename type="first">Z</forename><surname>Harris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="8,277.31,219.62,37.46,8.97">Language</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="190" to="222" />
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,239.54,401.42,8.97;8,111.58,251.50,101.56,8.97" xml:id="b11">
	<analytic>
		<title level="a" type="main" coord="8,152.76,239.54,238.55,8.97">New Stopping Criteria for Segmenting DNA Sequences</title>
		<author>
			<persName coords=""><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="8,409.09,239.54,100.16,8.97">Physical Review Letters</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="issue">25</biblScope>
			<biblScope unit="page" from="5815" to="5818" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,271.42,401.42,8.97;8,111.58,283.38,140.94,8.97" xml:id="b12">
	<monogr>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Monson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Carbonell</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Lavie</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">L</forename><surname>Levin</surname></persName>
		</author>
		<title level="m" coord="8,310.65,271.42,197.66,8.97">ParaMor: Finding Paradigms across Morphology</title>
		<meeting><address><addrLine>Berlin / Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,303.30,401.42,8.97;8,111.58,315.26,401.42,8.97;8,111.58,327.21,123.43,8.97" xml:id="b13">
	<analytic>
		<title level="a" type="main" coord="8,280.07,303.30,232.92,8.97;8,111.58,315.26,143.24,8.97">Towards Learning Morphology for Under-Resourced Fusional and Agglutinating Languages</title>
		<author>
			<persName coords=""><forename type="first">K</forename><surname>Shalonova</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Golénia</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Flach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="8,264.18,315.26,248.82,8.97;8,111.58,327.21,11.42,8.97">IEEE Transactions on Audio, Speech, and Language Processing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="956" to="965" />
			<date type="published" when="2009-07">July 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="8,111.58,347.14,401.42,8.97;8,111.58,359.09,401.42,8.97;8,111.58,371.05,120.08,8.97" xml:id="b14">
	<analytic>
		<title level="a" type="main" coord="8,375.97,347.14,137.03,8.97;8,111.58,359.09,146.65,8.97">Learning the morphology of Zulu with different degrees of supervision</title>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Spiegler</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Golénia</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">K</forename><surname>Shalonova</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Flach</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Tucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="8,278.69,359.09,159.89,8.97;8,471.75,359.09,36.77,8.97">Spoken Language Technology Workshop</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008-12">2008. Dec. 2008</date>
			<biblScope unit="page" from="9" to="12" />
		</imprint>
	</monogr>
	<note>SLT 2008</note>
</biblStruct>

<biblStruct coords="8,111.58,390.97,401.42,8.97;8,111.58,402.93,271.79,8.97" xml:id="b15">
	<analytic>
		<title level="a" type="main" coord="8,234.40,390.97,273.75,8.97">Automatic Term Extraction Based on Perplexity of Compound Words</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Yoshida</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Nakagawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="8,111.58,402.93,156.95,8.97">Natural Language Processing IJCNLP</title>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
			<biblScope unit="page" from="269" to="279" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
