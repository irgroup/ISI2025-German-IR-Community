<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,91.64,148.62,419.80,15.51;1,265.97,170.53,71.11,15.51">Allomorfessor: Towards Unsupervised Morpheme Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,189.78,204.00,64.91,9.96"><forename type="first">Oskar</forename><surname>Kohonen</surname></persName>
							<email>oskar.kohonen@tkk.fi</email>
							<affiliation key="aff0">
								<orgName type="department">Adaptive Informatics Research Centre</orgName>
								<orgName type="institution">Helsinki University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,263.21,204.00,59.38,9.96"><forename type="first">Sami</forename><surname>Virpioja</surname></persName>
							<email>sami.virpioja@tkk.fi</email>
							<affiliation key="aff0">
								<orgName type="department">Adaptive Informatics Research Centre</orgName>
								<orgName type="institution">Helsinki University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,349.61,204.00,63.64,9.96"><forename type="first">Mikaela</forename><surname>Klami</surname></persName>
							<email>mikaela.klami@tkk.fi</email>
							<affiliation key="aff0">
								<orgName type="department">Adaptive Informatics Research Centre</orgName>
								<orgName type="institution">Helsinki University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,91.64,148.62,419.80,15.51;1,265.97,170.53,71.11,15.51">Allomorfessor: Towards Unsupervised Morpheme Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">20E691C34D6EF48F4865E5F0DB6C2F84</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.2 [Artificial Intelligence]: I.2.6 Learning; I.2.7 Natural Language Processing Algorithms</term>
					<term>Experimentation</term>
					<term>Languages Morphology</term>
					<term>Morphological Analysis</term>
					<term>Unsupervised Learning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Many modern natural language processing applications would benefit from automatic morphological analysis of words, especially when dealing with morphologically rich languages. Consequently, there has been an increasing amount of research on the task of unsupervised segmentation of word forms into smaller useful units, i.e. morphs or morphemes. The linguistic phenomenon of allomorphy, where one morpheme has several different surface forms, places limits on the quality of morpheme analysis achievable by segmentation alone. We extend the morphological segmentation method, Morfessor Baseline, to model allomorphy. Our unsupervised method discovers common base forms for allomorphs from an unannotated corpus. We evaluate the method by participating in the Morpho Challenge 2008 competition, where automatic morphological analyses of corpora in English, German, Turkish and Finnish are compared against a linguistic gold standard. Our method achieves high precision, but low recall, and therefore low F-measure scores. We conclude that our method currently undersegments, but that the main approach is promising.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="595.0" lry="842.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Morphological analysis is crucial to many modern natural language processing applications, especially when dealing with morphologically rich languages where the enormous number of possible inflected word forms would otherwise lead to severe problems with data sparsity, computational efficiency, and general application performance. Consequently, there has recently been an increasing amount of research on the task of automatic unsupervised segmentation of word forms into smaller useful units, i.e. morphs or morphemes <ref type="bibr" coords="1,295.73,693.62,9.96,9.96" target="#b7">[8]</ref>. Many current morphological analysis tools are already capable of extracting ad-hoc morphological segmentations that are of good quality for the purposes of, e.g., speech recognition <ref type="bibr" coords="1,249.63,717.53,9.96,9.96" target="#b1">[2]</ref>.</p><p>Ultimately, we would like to perform not morphological segmentation, but the more difficult task of morpheme analysis, where the aim is not only to segment the corpus word forms into subparts, but also to identify surface forms corresponding to morphological labels. For this task, the phenomenon of allomorphy limits on the quality of morpheme analysis achievable by segmentation alone. Allomorphy is defined in linguistics as a morphological phenomenon in which an underlying morpheme-level unit may have two or more morph-level surface realizations which only occur in a complementary distribution: The occurrences of the different allomorphs of a given morpheme are conditioned by the morpho-and phonotactical environment of the morpheme, and any given environment may therefore trigger the occurrence of only one of the allomorphic variants. For example, in Finnish, the singular genitive case is marked with a suffix n, e.g. auto (car)auton (car's). Many Finnish nouns have allomorphic variation in their stems when producing the singular genitive: kenkä (shoe)kengän (shoe's), pappi (priest)papin (priest's), tapa (habit)tavan (habit's). A segmentation based approach does not model the fact that the allomorphic variation in the stems of the singular genitive represent the same morpheme as their base form.</p><p>Thus, instead of merely splitting the word forms into morph-like units, a morpheme analysis system should also be capable of reducing the potentially morphologically transformed stems into their lexical base forms, and handling cases of allomorphic variation in both stems and affixes.</p><p>In addition to being more linguistically motivated, it is well reasonable to expect that such a morpheme-level analysis would also prove to be superior to a mere segmentation of word forms for the purposes of many natural language processing applications, due to reductions in lexicon size and identification of base forms. Indeed, in Morpho Challenge 2007 <ref type="bibr" coords="2,391.73,350.46,9.96,9.96" target="#b6">[7]</ref>, the performances of the morphological analysis systems submitted to the contest were evaluated on an actual Information Retrieval task. However, even if the reduction of word forms into stems and adherent affixes should hypothetically be very valuable for an Information Retrieval task, the best challenge results were produced by methods that were mainly segmentation-based: Bernhard's method <ref type="bibr" coords="2,438.89,398.28,10.52,9.96" target="#b0">[1]</ref> and Morfessor Baseline <ref type="bibr" coords="2,129.20,410.24,10.52,9.96" target="#b2">[3,</ref><ref type="bibr" coords="2,143.05,410.24,7.01,9.96" target="#b3">4]</ref>.</p><p>As can be seen from the examples above, the allomorphic variations of a certain morpheme commonly have very similar orthographic forms. In this paper, we describe an extension to the Morfessor Baseline algorithm towards analyzing allomorphic variation, using string similarity to identify allomorphs. Our method provides a morphological segmentation and identifies potential base forms for stems, but not suffixes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Allomorfessor Model for Morpheme Analysis</head><p>Our learning problem is the following: We have an unannotated text corpus that contains words in their inflected forms. From this corpus we try to infer a morphological segmentation and a common base form for all inflected forms that stem from the same root word. Since our method is completely unsupervised, it cannot know which word form is considered the correct base form, but chooses one of the alternative forms as the base form. When successful, all allomorphic variants of a stem will be replaced by the chosen base form. Allomorphic variation in suffixes is not taken into account.</p><p>In this section, we describe a model that tries to solve the problem. We call the model Allomorfessor, as it is an extension to the Morfessor <ref type="bibr" coords="2,325.29,620.41,10.52,9.96" target="#b3">[4]</ref> method and tries to solve the problems caused by allomorphy. We start by discussing how Maximum a Posteriori estimation is applied to find the optimal probabilistic model. Then we show how instead of modeling the full corpus, we can model just a list of all the word forms in the corpus by using a very simple model for the word level. In subsections 2.4-2.5 we describe the morpheme-level model designed for finding allomorphic variants. Finally, we discuss the search algorithm for the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Maximum A Posteriori Estimation</head><p>Our model is probabilistic and generative, meaning that it can give a probability distribution over all possible text corpora. The model is denoted by M and the corpus used for training the model as corpus.</p><p>With Maximum a Posteriori (MAP) estimation, we try to find the model M that is the most probable given the training corpus:</p><formula xml:id="formula_0" coords="3,162.94,157.18,350.05,16.65">M MAP = arg max M P (M| corpus) = arg max M P (M)P (corpus|M)<label>(1)</label></formula><p>P (M) is the Bayesian prior probability for the model and P (corpus|M) is likelihood of the training corpus given the model. Compared to Maximum Likelihood (ML) estimation, MAP provides a systematic way of balancing the model complexity and accuracy, and thus helps with the problem of overlearning (see, e.g., chapter 3 in <ref type="bibr" coords="3,257.03,220.84,10.29,9.96" target="#b5">[6]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Word and Morpheme Submodels</head><p>Assume that our model consists of two parts, word-level model M W and morpheme-level model M M . Furthermore, both models can be divided into two parts: grammar G and lexicon L. Word grammar describes how words are combined to form sentences (or some other multi-word constructions) in the corpus. Word lexicon gives the words that can be used by the grammar. Similarly, morpheme grammar models word-internal syntax and morpheme lexicon gives the morphemes that construct the words. First we make two simplifying assumptions: word grammar is independent of the morpheme model, and morpheme grammar and morpheme lexicon are mutually independent. With this and the Bayes' rule with get the following:</p><formula xml:id="formula_1" coords="3,139.31,384.68,373.69,17.58">arg max GW ,LW ,GM ,LM P (corpus|G W , L W )P (L W |G M , L M )P (G W |L W )P (G M )P (L M ).<label>(2)</label></formula><p>We are currently interested in morpheme-level modeling, so we can set L W to be a lexicon consisting of all word forms in the training corpus and G W to be a unigram model. As both are constants with respect to the morph model, the task simplifies to:</p><formula xml:id="formula_2" coords="3,216.84,459.10,169.32,17.58">arg max GM ,LM P (L W |G M , L M )P (G M )P (L M ).</formula><p>(</p><formula xml:id="formula_3" coords="3,504.51,459.10,8.48,9.96">)<label>3</label></formula><p>This is equivalent to the approach used in Morfessor <ref type="bibr" coords="3,332.57,488.24,9.96,9.96" target="#b3">[4]</ref>, but instead of modeling the original corpus, we are now modeling a lexicon of the words in the corpus. <ref type="foot" coords="3,378.09,498.82,3.97,6.97" target="#foot_0">1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Model Overview</head><p>In its core, the Allomorfessor model is a probabilistic context-free grammar (PCFG). Terminals of the grammar are units resembling linguistical morphemes, specifically root stems and affixes. We call the non-terminals virtual morphs; they are units that have substructure. We denote both the virtual morphs and stems with µ. I.e., if µ does not have a substructure, it is a (root) stem, otherwise it is a virtual morph. For an illustration, see Figure <ref type="figure" coords="3,363.57,594.30,3.87,9.96">2</ref>.3. The model is similar to Morfessor Baseline: A word can either be a stem with no further substructure, or it can be a virtual morph consisting of two parts that in turn may be stems or virtual morphs. However, compared to Morfessor Baseline we add the notion of mutation to model allomorphic variation. A virtual morph splits the surface string in two parts, which we here call virtual prefix and virtual suffix, to avoid confusing them with actual prefix and suffix morphemes. In case of a compound word the virtual prefix may be the first word in the compound, and similarly for the virtual suffix. These virtual prefixes and suffixes might also still themselves have substructure. Our model allows mutations only to the virtual prefix. This means that a virtual morph consists of a base form, a virtual suffix, and a mutation that transforms the base form into the observed virtual prefix. The mutation may be empty, in which case the base form Figure <ref type="figure" coords="4,121.78,183.04,3.87,9.96">1</ref>: The analysis of the Finnish word jalkapallokengän (football shoe's). First the word is split in two with an empty mutation denoted as (), then the the virtual prefix jalkapallo is further split into the stems jalka and pallo. The virtual suffix kengän is split into the base form kenkä, the corresponding mutation (k|g) which transforms it into the virtual prefix kengä, and the stem n is simply the virtual prefix. An empty mutation corresponds to a regular inflection or compound word, where the stem does not undergo any changes.</p><p>For generality, mutations to the virtual suffix should also be modeled. However, we ignore it for now, since mutations to the virtual prefix are much more common in the studied languages. In principle, an equivalent solution should work for that case as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Model Probabilities</head><p>In this subsection, we give a formal description of the probabilities of Equation <ref type="formula" coords="4,434.72,351.27,4.98,9.96" target="#formula_3">3</ref>for the Allomorfessor model. (For simplicity, the subscript M of is left out from the symbols denoting morpheme model parts.) The formulation follows closely the work by Creutz and Lagus <ref type="bibr" coords="4,428.09,375.18,9.96,9.96" target="#b3">[4]</ref>.</p><p>Every word form in the word lexicon is represented by one virtual morph. Thus the probability of the word lexicon is simply</p><formula xml:id="formula_4" coords="4,246.09,410.03,266.91,31.30">P (L W |G, L) = MW j=1 P (µ j ),<label>(4)</label></formula><p>where M W is the number of words in the lexicon. The probability of the morph µ is estimated from its frequency: the more often morph is referred to, either from the word lexicon, or from virtual morphs, the more probable it is. The morph lexicon L consists of the virtual morphs. The probability of the morph lexicon is based on the properties of the virtual morphs</p><formula xml:id="formula_5" coords="4,162.83,517.89,350.17,10.71">P (L) = P (size(L) = M )P (properties(µ 1 ) . . . properties(µ M ))M !<label>(5)</label></formula><p>If a non-informative prior is used for the probability of the lexicon size, its effect is minimal and it can be neglected. The factor M ! is explained by the fact that there are M ! possible orderings of M items, and the lexicon is the same regardless of the order in which the morphs are discovered. The properties of the morphs are divided into two parts, usage and form:</p><formula xml:id="formula_6" coords="4,142.87,587.72,370.12,25.66">P (properties(µ 1 ) . . . properties(µ M )) = P (usage(µ 1 ) . . . usage(µ M )) × P (form(µ 1 ) . . . form(µ M ))<label>(6)</label></formula><p>The usage includes properties of the morph itself and the properties of its context. In this model, we use only morph frequencies. For the probability of the frequency distribution, we use a non-informative, implicit frequency prior</p><formula xml:id="formula_7" coords="4,148.79,661.74,359.97,23.53">P (usage(µ 1 ) . . . usage(µ M )) = P (freq(µ 1 ) . . . freq(µ M )) = 1/ N -1 M -1 , (<label>7</label></formula><formula xml:id="formula_8" coords="4,508.75,668.48,4.24,9.96">)</formula><p>where N is the sum of the frequencies of the morphs. The form of a morph is its symbolic representation. Forms of the morphs are assumed to be independent:</p><formula xml:id="formula_9" coords="4,203.25,726.99,309.74,31.18">P (form(µ 1 ) . . . form(µ M )) = M i=1 P (f orm(µ i ))<label>(8)</label></formula><p>As described, the morph lexicon L, has a hierarchical structure. µ i is either a root stem represented by a string of letters or a virtual morph consisting of a base form, a virtual suffix and a (possibly empty) mutation δ k . The base form µ j and virtual suffix µ k may be stems or virtual morphs.</p><formula xml:id="formula_10" coords="5,95.92,155.39,412.83,26.19">P (f orm(µ i )) = 1 -P (sub) P (length(µ i )) length(µi) j=1 P (ĉ ij ), if µ i is a stem P (sub) P (µ j )P (δ k )P (µ k ), if µ i is a virtual morph. (<label>9</label></formula><formula xml:id="formula_11" coords="5,508.76,163.68,4.24,9.96">)</formula><p>For stems, ĉij is the jth character of the stem, and P (sub) is the probability that a morph has substructure.</p><p>The lengths of the morphs are modeled explicitly using a gamma distribution:</p><formula xml:id="formula_12" coords="5,196.11,233.80,312.45,23.53">P (length(µ)) = 1 Γ(a)b a length(µ) a-1 e -length(µ)/b . (<label>10</label></formula><formula xml:id="formula_13" coords="5,508.56,240.54,4.43,9.96">)</formula><p>Grammar G of the model contains the set of mutations ∆. Similarly to the lexicons,</p><formula xml:id="formula_14" coords="5,157.61,287.35,355.38,10.71">P (G) = P (size(∆) = M δ )P (properties(δ 1 ) . . . properties(δ M δ ))M δ !,<label>(11)</label></formula><p>and properties can be divided into usage and form. Usage features include only the frequencies; the non-informative prior is applied. The probabilities for forms of mutations are given in the following sections that examine mutations more closely. Mutations that occur often are much more likely to correspond to correct, systematic analyses that could be seen as being part of the language. Therefore they are sensible to model in their own lexicon, rather than modeling each use of a mutation independently. Because of this modeling decision, it becomes important that the mutations are such that when the linguistically equivalent changes happen for two pairs of words, also the applied mutation is the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Mutations</head><p>When designing the mutations for modeling allomorphy, there are several considerations that need to be balanced. First, if we are not careful in how our mutations are allowed to change the stem, we easily get incorrect analyses. For example, the edit distance between beat and peat is only one, but they are certainly not allomorphs of the same morpheme, but rather distinct morphemes. As a general rule, with a few obvious exceptions, it appears that allomorphic variation happens close to the affix. Therefore we limit our mutations to modify the end of the base form, since our mutations only affect the virtual prefix. Second, we would like our mutation lexicon to extract common orthographical rules. For example, in some English stems the ending letter y will change to i: denydenied or pretty prettier. A less regular example is the Finnish genitive, where there is a "softening" of the preceding consonants, for example: kenkä (shoe)kengän, tanko (pole)tangon, pappi (priest) papin. In the ideal case the same mutation could express the common rule. More pragmatically, complex cases, such as the Finnish genitive, should be modeled with as few different mutations as possible.</p><p>Third, to be computationally feasible, the mutations need to be efficient to compute from a pair of strings. This makes restrictions especially to very flexible mutation types.</p><p>We consider two kinds of mutations: 1) morph-end mutations and 2) substitution-deletion mutations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">Morph-End Mutations</head><p>This class of mutations is very simple: Mutation describes what is to be removed from the end of the base form, and what needs to be added to yield the virtual prefix. For example if the base form is deny and the virtual prefix is deni (for example combined with the suffix ed). Then this mutation would be denoted -y+i. In other words, the mutation consists of two operations: Deleting y and then adding i. In case more needs to be removed or added, we simply add more operations, e.g. ihminen (human) -nen+sen → ihmisen (human's).</p><p>The probability of the form for these mutations is set to be P (form(δ i )) = P ((length(ops δi )) ops j P (op j ) (12)</p><formula xml:id="formula_15" coords="6,202.67,164.56,310.32,26.32">P (op j ) = P (del) 1 Σ if op j is a deletion P (ins) 1 Σ if op j is an insertion ,<label>(13)</label></formula><p>In the equations above, ops δi is the set of operations in the mutation δ i , P ((length(ops δi )) is a gamma distribution, similarly to the Equation 10, and Σ is the alphabet size, which is included because a specific letter is deleted or inserted. The probabilities P (del) and P (ins) denote the relative probabilities of deletions and insertions. The weakness of this mutation type is that it cannot generalize mutations where a letter inside the base form changes. For example, the mutation is intuitively the same in the following case: kenkäkengän and tankotangon. The second to last letter k is changed into a g. However, with the simple mutations presented the mutations would be different, -kä+gä and -ko+go, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2">Substitution-Deletion Mutations</head><p>This is a more complicated mutation type which solves the problem described at the end of the previous section. In this mutation type, there are two operations: substitutions and deletions of individual letters. If a base form candidate cannot be transformed into the target stem using these operations only, that base form candidate is discarded. The reasoning behind this is that the virtual suffix should be the one adding letters to the end of the virtual morph, not the mutation.</p><p>The operations themselves also work as follows. The operation contains a target letter to modify. The execution of the mutation starts scanning from the end of the base form until the target letter is found. Once found, the operation is applied. In case of a substitution, the target letter is replaced, in case of deletion, it is deleted. The next operation starts scanning for its target from the position before the one where the previous operation was applied. This is continued until no operations remain. For example, mutating kenkä into kengä is done using the mutation k|g, where x|y denotes an operation where the letter x is substituted with the letter y. First we scan from the end of the string searching for the target letter k. Once we find it, we replace it with a g. Note that the same mutation also changes tanko into tango. For a more complicated example, consider changing ranta (shore) into rann. The needed mutation is -a t|n, where the operations are separated by spaces, and -x means deletion of the target letter x. Thus the whole execution proceeds: Find the o that is last in the base form and delete it. Then find the previous t from the position left of the first operation, and replace it with an n.</p><p>There are some cases where the scanning process as described thus far is inadequate. For example ihminen (human)ihmisen (human's). For these cases we augment the scanning with a possibility to skip letters. To express "change the second last n to an s" we write 2n|s, i.e., a number expresses which letter of it's kind to match. When the first one is desired the number may be omitted.</p><p>Calculating the smallest mutation of this kind for arbitrary strings is not a trivial task. We build on work in approximate string matching. There exists powerful dynamic programming based algorithms to calculate the Levenshtein (edit) distance (see, e.g., <ref type="bibr" coords="6,372.52,625.43,9.96,9.96" target="#b8">[9]</ref>, section 5.1.1 and 5.1.3). The Levenshtein distance measures the distance between two strings by how many insertion, deletion and substitution operations are needed to convert one string to another. It is also possible to assign different costs to the different operations. It is fairly easy to modify the basic algorithm (described in <ref type="bibr" coords="6,148.82,673.24,10.52,9.96" target="#b8">[9]</ref> section 5.1) to not only produce the distance itself, but also the optimal sequence of operations. This can be done by iterating backwards through the cost matrix produced by the calculation, and always choose the cheapest parent node, in a similar way to how the Viterbi algorithm finds the maximum likelihood path in a Hidden Markov Models.</p><p>In our case, we want the optimal path, but it should not contain insertions. Therefore we set the cost on the insertion operation to a number larger than 2 * max(length(s), length(t)), where s is the source string, that is the base form and t is the target string, that is the virtual prefix. The weights on substitution and deletion are set to 2 and 1 respectively, to favor deletions, but since we don't currently use the resulting distance, they could also both be set to 1. If there are alternative paths of which some contain insertions and others do not, the ones that do not will always be cheaper, because of the high cost of insertions. If the edit distance returned is larger than the weight set for the insertions, then we know that insertions were necessary, and can discard the candidate base form immediately. Once we have a path of optimal substitutions and deletions, given the above constraints, we can easily transform those into the mutation format described earlier.</p><p>The prior probability for the substitution-deletion mutations was selected to be as follows:</p><formula xml:id="formula_16" coords="7,173.59,225.75,339.40,31.65">P (form(δ i )) = P (length(ops δi )) ops j P (skip j )P (op j )<label>(14)</label></formula><p>P (skip j ) = P (length(skip(op j ))) ( <ref type="formula" coords="7,499.72,262.00,8.85,9.96">15</ref>)</p><formula xml:id="formula_17" coords="7,194.60,276.51,318.39,26.33">P (op j ) = P (del) 1 Σ if op j is a deletion P (sub) 1 Σ 2 if op j is an substitution<label>(16)</label></formula><p>The formulas are similar to Equations 13 and 13, but there is a separate gamma distribution P (length(skip(op j ))) for the skips. Since the substitution operation requires the choice of both the target letter and the replacing one, the alphabet size Σ is squared in the denominator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Learning the Model</head><p>Our model learning scheme is based on iteratively improving the model probability</p><formula xml:id="formula_18" coords="7,90.00,381.40,423.01,22.66">P (L W |G M , L M ) P (G M )P (L M</formula><p>), by analyzing one word at the time, and selecting the analysis of that word that maximizes the probability. First, we look at the case where the mutation is empty. That case is equivalent to the search algorithm used in Morfessor Baseline. We analyze the word w which can be split between any pair of letters. If follows that each word w has 2 len(w)-1 possible analyses. In order to reduce the search space, we search greedily for the split that maximizes the model probability. Unless w is best most probable to be a stem, we recursively repeat the process for the parts of the virtual morph. In other words, for each word w, we evaluate the model probability when w is analyzed either as a stem or a virtual morph split at position i ∈ 1, len(w) -1. Should the virtual morph maximize model probability, we recursively perform the same analysis on both virtual prefix and virtual suffix.</p><p>Now we look at the case where the mutation is nonempty. Because we are trying to find common base forms for different allomorphs, we restrict the stem to be a word that exists in the dictionary. Alternatively, one could restrict to any morph that exists in the lexicon. We chose the former as a conservative alternative. The words in the dictionary are assumed to be real words, whereas the morph lexicon might contain incorrect analyses. <ref type="foot" coords="7,355.63,571.31,3.97,6.97" target="#foot_1">2</ref> As before, we split the word w at position i so that the virtual prefix v pre = w 0..(i-1) and the virtual suffix v suf = w i..(len(w)-1) , where w i..j denotes the part of the string w starting at position i and ending at position j. A brute-force algorithm would for each v pre consider each other word w ′ from the lexicon as a candidate base form. This would lead to (len(w) -1) N (N -1) 2 comparisons, where N is the number of words in the corpus. This is clearly infeasible for large data sets.</p><p>The majority of words are poor candidates for base forms, since they do not share much in common with the target virtual prefix v pre . Therefore, we further assume that the base form needs to share a common prefix with the target word. Finding candidates with a shared prefix from an ordered list can be done in O(k log(N )) time, where k is the number of found candidates. We can further reduce the search time by doing it only once for each word w, rather than for each v pre . For the whole search algorithm we thus have time complexity O(N k log(N )). Unfortunately k also grows somewhat with N , and it therefore becomes necessary limit the amount of candidates considered per word. We limit it by a parameter K. To alleviate the effect of this limitation, we try to consider the best candidates first, so that worse ones are eliminated.</p><p>Our exact search for candidate base forms is the following. For virtual morph µ:</p><p>• If length(µ) &lt; 4 don't consider any base forms</p><p>• If 4 &lt; length(µ) &lt; 6, search for candidates that share prefix µ 0..length(µ)-3</p><p>• If length(µ) &gt; 6, search candidates that share prefix w 0..length(µ)-4</p><p>Then for each v pre = µ 0..(i-1) , v suf = µ i..(length(µ)-1) :</p><p>• If length(v suf ) ≤ 5 and v suf exists in the lexicon and we have considered less than K candidates for virtual morph µ: Consider candidates one at the time, starting with those of the same length as stm, and working towards shorter ones, but never shorter than length(v pre )-2.</p><p>Calculate the needed mutation, and calculate model probability.</p><p>• Otherwise don't consider any base forms</p><p>In one epoch we go through each word in the corpus in random order. The process is repeated until the model probability stops improving significantly. In practice, 2-6 epochs are usually sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiments</head><p>The model was evaluated in Morpho Challenge 2008 competition. Here we describe the datasets, the evaluation method, and the results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head><p>We trained our model on four of the datasets provided in Morpho Challenge 2008: English, German, Turkish and Finnish. Table <ref type="table" coords="8,253.74,459.47,4.98,9.96" target="#tab_0">1</ref> shows the sizes of the sets. Further details of the datasets are found from the web page<ref type="foot" coords="8,215.41,470.05,3.97,6.97" target="#foot_2">3</ref> of the challenge. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation</head><p>The method was evaluated in Competition 1 of the Morpho Challenge 2008. The task was to return a list where each word form in the training data was followed by its analysis. This analysis was compared to linguistic gold standard. In the gold standard analyses we have analyses such as flying FLY V +PCP1, where FLY V is the base form and +PCP1 refers to an inflectional morpheme.</p><p>As the labels of the morphemes are not relevant (or even possible to obtain for an unsupervised algorithm), the closeness of the gold standard was evaluated by taking word pairs which share a morpheme in one analysis (either gold standard or the submitted one) and checking if they share some morpheme also in the other. Details are provided in Morpho Challenge web page and <ref type="bibr" coords="8,491.44,725.22,9.96,9.96" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Model Parameters</head><p>Although our algorithm is mainly unsupervised, some general prior parameters must be set by hand. As parameters for the morph lexicon length distribution in Equation 10 we used for shape a = 5 and scale b = 1, which expresses the prior belief that morphs in the lexicon are most likely to be 5 characters long. We had to modify the model search method to the one described in Section 2.6, and therefore we were only able to train models using substitution-deletion mutations, and not on morph-end mutations. The parameter K denoting the number of candidates considered at for each virtual morph was set to 20. For the mutations in Equation <ref type="formula" coords="9,410.16,201.47,8.45,9.96">15</ref>, we used parameters a = 1 and b = 1 of the gamma length prior to model prefer short mutations, and the probability deletions and insertions in Equation 16 was set to 0.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Results</head><p>The results provided by the Morpho Challenge organizers are summarized in Table <ref type="table" coords="9,459.85,271.66,3.87,9.96" target="#tab_1">2</ref>. It can be seen that our precision is quite good, especially for Turkish and Finnish. However, the recall is very poor. Low recall numbers mean that the model undersegments heavily, i.e., most of the relevant morphemes are missing from the analysis. Mutations were not used very frequently in the analyses. E.g., of the cases where substructure was found in the word form, 98% of the mutations were empty for English and 96% for Finnish. The five most common mutations for English and Finnish are given in Table <ref type="table" coords="9,430.88,504.28,3.87,9.96" target="#tab_2">3</ref>, with one typical example analysis for each. Part of the usages are desired (e.g., -e in abjure, -a in haljeta), but there are many cases where the mutation is clearly unnecessary. E.g., a simpler analysis for suspicions would be suspicion () s. Mutations are also used quite commonly in misspelled words. E.g., both contructed and contructive exist in the English corpus, and mutation -d-e is used to get the missing base form contruct. 6241 haljeta (-a) essa (-i) 4203 kliimaksi (-i) in (-a-t)</p><p>2792 alokkaita (-a-t) lle</p><p>As our model suffers from undersegmentation, we need to address that problem first. In practice, undersegmentation means that the cost of the substructure for a word is too large compared to direct coding as letters. The reason might be an unwanted bias in the model probabilities, or just an error in the implementation. Also the search algorithm of the model is currently quite heuristic, and a more principled approach needs to be developed. To improve the greedy optimization, we are considering learning procedures based on simulated annealing. The model described in this paper uses no global information at all. In contrast, Dasgupta and Ng <ref type="bibr" coords="10,124.65,216.86,10.52,9.96" target="#b4">[5]</ref> extract orthographic rules in a global fashion, and <ref type="bibr" coords="10,358.49,216.86,48.49,9.96;10,438.78,216.86,10.45,9.96">Creutz and [4]</ref> use perplexity to classify morphs into stems, prefixes and suffixes. There may be a need for including this kind of information into the training procedure.</p><p>It is clear that the correct morphological analysis, or even segmentation, of a word is dependent on its word-level context. (E.g., thought can be either an inflected verb or a noun.) At some stage, we want to incorporate sentence and word analysis to the model. I.e., instead of setting the word-level parts in Equation <ref type="formula" coords="10,219.21,288.59,4.98,9.96" target="#formula_1">2</ref>to constants, we may use them to model the context. Especially useful may be combining part-of-speech tagging and morphological analysis: On one hand, if POS of the word is known, the possible morphemes are restricted. On the other hand, if our analysis contain a certain suffix that occurs only in, e.g., verbs, selecting the POS for the word is trivial.</p><p>We conclude that despite the current method's disappointing results, we find the general approach to be promising and the problem worth further research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="8,200.09,502.20,202.83,79.45"><head>Table 1 :</head><label>1</label><figDesc>Sizes of the datasets used in training.</figDesc><table coords="8,216.33,523.47,170.32,58.18"><row><cell cols="3">Language Word tokens Word types</cell></row><row><cell>English</cell><cell>62 185 728</cell><cell>384 903</cell></row><row><cell>Finnish</cell><cell>36 207 308</cell><cell>2 206 719</cell></row><row><cell>German</cell><cell>46 338 213</cell><cell>1 266 159</cell></row><row><cell>Turkish</cell><cell>12 862 393</cell><cell>617 298</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="9,90.00,338.30,423.00,116.50"><head>Table 2 :</head><label>2</label><figDesc>Results of the Morpho Challenge evaluation. Precision measures how well of the morphemes found by the algorithm match the ones in gold standard analysis. Recall measures how extensively the gold standard morphemes are found by the algorithm. F-measure is the harmonic mean of precision and recall.</figDesc><table coords="9,203.71,395.43,194.86,59.37"><row><cell cols="2">Language Precision Recall</cell><cell>F-Measure</cell></row><row><cell>English 83.39%</cell><cell cols="2">13.43% 23.13%</cell></row><row><cell>German 87.92%</cell><cell>7.44%</cell><cell>13.71%</cell></row><row><cell>Turkish 93.25%</cell><cell>6.15%</cell><cell>11.53%</cell></row><row><cell>Finnish 92.55%</cell><cell>6.89%</cell><cell>12.82%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="9,90.00,595.38,423.01,103.90"><head>Table 3 :</head><label>3</label><figDesc>The five most frequent mutations found by the algorithm for English (left side) and Finnish (right side).</figDesc><table coords="9,118.35,629.15,366.30,70.14"><row><cell cols="2">Mutation Freq. Example</cell><cell>Mutation</cell><cell>Freq. Example</cell></row><row><cell>-e</cell><cell>2033 abjure (-e) ed</cell><cell>(-n)</cell><cell>27510 antiikin (-n) lle</cell></row><row><cell>-s</cell><cell>537 actress (-s) s'</cell><cell>(-n-e)</cell><cell>15830 edustajien (-n-e) esi</cell></row><row><cell>-y</cell><cell>386 inequity (-y) able</cell><cell>(-a)</cell><cell></cell></row><row><cell>-n</cell><cell>243 suspicion (-n) ns</cell><cell></cell><cell></cell></row><row><cell>-d-e</cell><cell>183 contructed (-d-e) ive</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0" coords="3,105.25,733.27,407.69,7.24;3,90.00,742.74,174.86,7.24"><p>This has been recommended to be done also with Morfessor by setting all the word counts to one. Otherwise, frequent word forms are often undersegmented.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1" coords="7,105.25,737.37,407.68,7.24;7,90.00,746.83,365.82,7.24"><p>We did also some preliminary experiments using the morph lexicon, but it appeared not to improve the results, so it was discarded over the simpler implementation of considering only words in the word lexicon.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2" coords="8,105.25,745.28,173.35,7.35"><p>http://www.cis.hut.fi/morphochallenge2008</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="10,105.50,403.14,407.50,9.96;10,105.50,415.09,291.76,9.96" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="10,194.24,403.14,271.72,9.96">Simple morpheme labelling in unsupervised morpheme analysis</title>
		<author>
			<persName coords=""><forename type="first">Delphine</forename><surname>Bernhard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="10,485.60,403.14,27.40,9.96;10,105.50,415.09,170.48,9.96">Working notes for the CLEF 2007 Workshop</title>
		<meeting><address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,435.01,407.52,9.96;10,105.50,446.97,407.51,9.96;10,105.50,458.93,407.51,9.96;10,105.50,470.88,254.40,9.96" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="10,456.18,446.97,56.83,9.96;10,105.50,458.93,334.12,9.96">Morph-based speech recognition and modeling of out-of-vocabulary words across languages</title>
		<author>
			<persName coords=""><forename type="first">Mathias</forename><surname>Creutz</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Teemu</forename><surname>Hirsimäki</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Mikko</forename><surname>Kurimo</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Antti</forename><surname>Puurula</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Janne</forename><surname>Pylkkönen</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Vesa</forename><surname>Siivola</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Matti</forename><surname>Varjokallio</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Ebru</forename><surname>Arisoy</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Murat</forename><surname>Saraçlar</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Andreas</forename><surname>Stolcke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="10,448.28,458.93,64.73,9.96;10,105.50,470.88,177.54,9.96">ACM Transactions on Speech and Language Processing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,490.80,407.50,9.96;10,105.50,502.76,407.50,9.96;10,105.50,514.72,112.28,9.96" xml:id="b2">
	<analytic>
		<title level="a" type="main" coord="10,255.26,490.80,161.11,9.96">Unsupervised discovery of morphemes</title>
		<author>
			<persName coords=""><forename type="first">Mathias</forename><surname>Creutz</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Krista</forename><surname>Lagus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="10,436.46,490.80,76.55,9.96;10,105.50,502.76,284.36,9.96">Proceedings of the Workshop on Morphological and Phonological Learning of ACL&apos;02</title>
		<meeting>the Workshop on Morphological and Phonological Learning of ACL&apos;02<address><addrLine>Philadelphia, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="21" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,534.64,407.51,9.96;10,105.50,546.60,407.52,9.96;10,105.50,558.55,22.68,9.96" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="10,269.65,534.64,243.37,9.96;10,105.50,546.60,88.50,9.96">Unsupervised models for morpheme segmentation and morphology learning</title>
		<author>
			<persName coords=""><forename type="first">Mathias</forename><surname>Creutz</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Krista</forename><surname>Lagus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="10,203.97,546.60,241.37,9.96">ACM Transactions on Speech and Language Processing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2007-01">January 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,578.47,407.49,9.96;10,105.50,590.43,407.51,9.96;10,105.50,602.39,213.86,9.96" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="10,250.89,578.47,262.10,9.96;10,105.50,590.43,42.07,9.96">High-performance, language-independent morphological segmentation</title>
		<author>
			<persName coords=""><forename type="first">Sajib</forename><surname>Dasgupta</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Vincent</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="10,181.73,590.43,331.27,9.96;10,105.50,602.39,182.05,9.96">the annual conference of the North American Chapter of the Association for Computational Linguistics (NAACL-HLT)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,622.31,347.01,9.96" xml:id="b5">
	<monogr>
		<title level="m" type="main" coord="10,190.27,622.31,151.07,9.96">Unsupervised Language Acquisition</title>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">G</forename><surname>De Marcken</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>MIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct coords="10,105.50,642.24,407.50,9.96;10,105.50,654.19,355.14,9.96" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="10,336.10,642.24,176.91,9.96">Overview of Morpho Challenge in CLEF</title>
		<author>
			<persName coords=""><forename type="first">Mikko</forename><surname>Kurimo</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Mathias</forename><surname>Creutz</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Ville</forename><surname>Turunen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="10,145.06,654.19,194.30,9.96">Working notes for the CLEF 2007 Workshop</title>
		<meeting><address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,105.50,674.12,407.49,9.96;10,105.50,686.07,99.70,9.96" xml:id="b7">
	<monogr>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName coords=""><surname>Matthews</surname></persName>
		</author>
		<title level="m" coord="10,192.82,674.12,211.89,9.96">Morphology (Cambridge Textbooks in Linguistics)</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct coords="10,105.50,705.99,407.50,9.96;10,105.50,717.96,79.14,9.96" xml:id="b8">
	<analytic>
		<title level="a" type="main" coord="10,192.59,705.99,210.42,9.96">A guided tour to approximate string matching</title>
		<author>
			<persName coords=""><forename type="first">Gonzalo</forename><surname>Navarro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="10,416.96,705.99,91.78,9.96">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="88" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
