<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,198.66,115.90,218.03,12.90;1,234.49,133.83,146.39,12.90;1,223.43,153.68,168.50,10.75">Kernel Methods and String Kernels for Authorship Analysis Notebook for PAN at CLEF 2012</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,230.16,190.08,63.92,8.64"><forename type="first">Marius</forename><surname>Popescu</surname></persName>
							<email>popescunmarius@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Bucharest</orgName>
								<address>
									<country key="RO">Romania</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,317.92,190.08,62.80,8.64"><forename type="first">Cristian</forename><surname>Grozea</surname></persName>
							<email>cristian.grozea@brainsignals.de</email>
							<affiliation key="aff1">
								<orgName type="institution">Fraunhofer FOKUS</orgName>
								<address>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,198.66,115.90,218.03,12.90;1,234.49,133.83,146.39,12.90;1,223.43,153.68,168.50,10.75">Kernel Methods and String Kernels for Authorship Analysis Notebook for PAN at CLEF 2012</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7A788B2D6CA5E62B7FEB3106D4E1DEE6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents our approach to the PAN 2012 Traditional Authorship Attribution tasks and the Sexual Predator Identification task. We approached these tasks with machine learning methods that work at the character level. More precisely, we treated texts as just sequences of symbols (strings) and used string kernels in conjunction with different kernel-based learning methods: supervised and unsupervised. The results were extremely good, we ranked first in most problem and overall in the traditional authorship attribution task, according to the evaluation provided by the organizers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This paper presents our approach to the PAN 2012 Traditional Authorship Attribution tasks: closed-class / open-class attribution, authorship clustering / intrinsic plagiarism and Sexual Predator Identification task. We approached these tasks with machine learning methods that work at the character level. More precisely, we treated texts as just sequences of symbols (strings) and used string kernels in conjunction with different kernel-based learning methods: supervised and unsupervised.</p><p>Using words is natural in text analysis tasks like text categorization (by topic), authorship identification and plagiarism detection. Perhaps surprisingly, recent results have proved that methods handling the text at character level can also be very effective in text analysis tasks <ref type="bibr" coords="1,221.07,512.97,11.56,8.64" target="#b6">[7,</ref><ref type="bibr" coords="1,232.63,512.97,11.56,8.64" target="#b11">12,</ref><ref type="bibr" coords="1,244.20,512.97,11.56,8.64" target="#b9">10,</ref><ref type="bibr" coords="1,255.76,512.97,7.71,8.64" target="#b3">4,</ref><ref type="bibr" coords="1,263.47,512.97,7.71,8.64" target="#b8">9]</ref>. In <ref type="bibr" coords="1,289.20,512.97,11.61,8.64" target="#b6">[7]</ref> string kernels were used for document categorization with very good results. Trying to explain why treating documents as symbol sequences and using string kernels led to such good results the authors suppose that: "the [string] kernel is performing something similar to stemming, hence providing semantic links between words that the word kernel must view as distinct". String kernels were also successfully used in authorship identification <ref type="bibr" coords="1,359.92,572.75,15.77,8.64" target="#b11">[12,</ref><ref type="bibr" coords="1,375.69,572.75,11.83,8.64" target="#b9">10]</ref>. A possible reason for the success of string kernels in authorship identification is given in <ref type="bibr" coords="1,401.59,584.71,15.49,8.64" target="#b9">[10]</ref>: "the similarity of two strings as it is measured by string kernels reflects the similarity of the two texts as it is given by the short words (2-5 characters) which usually are function words, but also takes into account other morphemes like suffixes ('ing' for example) which also can be good indicators of the author's style".</p><p>Even more interesting is the fact that two methods that obtained very good results for text categorization (by topic) <ref type="bibr" coords="1,269.96,656.44,11.62,8.64" target="#b6">[7]</ref> and authorship identification <ref type="bibr" coords="1,403.38,656.44,16.60,8.64" target="#b9">[10]</ref> are essentially the same, both are based on SVM and a string kernel of length 5. How is this possible? Traditionally, the two tasks, text categorization (by topic) and authorship identification are viewed as opposed. When words are used as features, for text categorization the (stemmed) content words are used (the stop words being eliminated), while for authorship identification the function words (stop words) are used as features, the others words (content words) being eliminated. Then, why did the same string kernel (of length 5) work well in both cases? In our opinion the key factor is the kernel-based learning algorithm. The string kernel implicitly embeds the texts in a high dimensional feature space, in our case the space of all (sub)strings of length 5. The kernel-based learning algorithm (SVM or another kernel method), aided by regularization, implicitly assigns a weight to each feature, thus selecting the features that are important for the discrimination task. In this way, in the case of text categorization the learning algorithm (SVM) enhances the features (substrings) representing stems of content words, while in the case of authorship identification the same learning algorithm enhances the features (substrings) representing function words.</p><p>Using string kernels will make the corresponding learning method completely language independent because the texts will be treated as sequences of symbols (strings). Methods working at the word level or above very often restrict their feature space according to theoretical or empirical principles. For example, they select only features that reflect various types of spelling errors or only some type of words (function words) <ref type="bibr" coords="2,134.77,358.62,10.58,8.64" target="#b0">[1]</ref>, etc.. These features prove to be very effective for specific tasks, but other, possibly good features, depending on the particular task, may exist. String kernels embed the texts in a very large feature space (all substrings of length k) and leave it to the learning algorithm (SVM or others) to select important features for the specific task, by highly weighting these features.</p><p>A method that uses words as features can not be language independent. Even a method that uses as features only function words is not completely language independent because it needs a list of function words (specific to a language) and a way to segment a text into words which is not an easy task for some languages, like Chinese.</p><p>The rest of the paper is organized as follows: the next section presents the string kernels used, the following three sections: Authorship Attribution, Authorship Clustering and Sexual Predator Identification correspond to each major sub-task and describe for each of those the specific kernel method used, how it was applied and what were the results obtained. The paper ends with a conclusions section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">String Kernels</head><p>Kernel-based learning algorithms work by embedding the data into a feature space (mathematically a Hilbert space), and searching for linear relations in that space. The embedding is performed implicitly, that is by specifying the inner product between each pair of points rather than by giving their coordinates explicitly.</p><p>Given an input set X (the space of examples), and an embedding vector space F (feature space), let φ : X → F be an embedding map called feature map.</p><p>A kernel is a function k, such that for all x, z ∈ X , k(x, z) =&lt; φ(x), φ(z) &gt;, where &lt; ., . &gt; denotes the inner product in F.</p><p>The kernel function offers to the kernel methods the power to naturally handle input data that are not in the form of numerical vectors, for example strings. The kernel function captures the intuitive notion of similarity between objects in a specific domain and can be any function defined on the respective domain that is symmetric and positive definite. For strings, many such kernel functions exist with various applications in computational biology and computational linguistics <ref type="bibr" coords="3,347.03,179.09,15.27,8.64" target="#b12">[13]</ref>.</p><p>Perhaps one of the most natural ways to measure the similarity of two strings is to count how many substrings of length p the two strings have in common. This gives rise to the p-spectrum kernel. Formally, for two strings over an alphabet Σ, s, t ∈ Σ * , the p-spectrum kernel is defined as:</p><formula xml:id="formula_0" coords="3,240.58,248.30,134.19,20.06">k p (s, t) = v∈Σ p num v (s)num v (t)</formula><p>where num v (s) is the number of occurrences of string v as a substring in s<ref type="foot" coords="3,454.77,277.82,3.49,6.05" target="#foot_0">3</ref> . The feature map defined by this kernel associates to each string a vector of dimension |Σ| p containing the histogram of frequencies of all its substrings of length p (p-grams).</p><p>A variant of this kernel can be obtained if the embedding feature map is modified to associate to each string a vector of dimension |Σ| p containing the presence bits (instead of frequencies) of all its substrings of length p. Thus the character p-grams presence bits kernel is obtained:</p><formula xml:id="formula_1" coords="3,246.43,360.79,122.50,22.13">k 0/1 p (s, t) = v∈Σ p in v (s)in v (t)</formula><p>where in v (s) is 1 if string v occurs as a substring in s and 0 otherwise. Normalized versions of these kernels</p><formula xml:id="formula_2" coords="3,174.27,418.04,265.89,31.86">kp (s, t) = k p (s, t) k p (s, s)k p (t, t) k0/1 p (s, t) = k 0/1 p (s, t) k 0/1 p (s, s)k 0/1 p (t, t)</formula><p>ensure a fair comparison of strings of different lengths.</p><p>For the traditional authorship attribution tasks we have used a p-spectrum normalized kernel of length 5 ( k5 ). We have chosen the length 5 because it was reported to work well in the case of document categorization <ref type="bibr" coords="3,331.66,497.18,11.62,8.64" target="#b6">[7]</ref> and authorship identification <ref type="bibr" coords="3,461.50,497.18,15.27,8.64" target="#b9">[10]</ref>. See also the comments from the introduction.</p><p>Because the p-spectrum kernel works at the character level, we didn't need to split the texts into words, or to do any NLP-specific preprocessing. The only editing done to the texts was the replacing of sequences of consecutive space characters (space, tab, new line, etc.) with a single space character. This normalization was needed in order to not artificially increase or decrease the similarity between texts as a result of different spacing. Also all uppercase letters were converted to the corresponding lowercase ones.</p><p>For sexual predator identification task the character p-grams presence bits kernel (normalized) of length 5 ( k0/1 5 ) was used. The motivations for this choice are given in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Authorship Attribution</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Closed-Class Attribution</head><p>Closed-class attribution sub-task is a typical instance of a multiclass classification problem, the main particularity in this challenge being the small number of training examples available (2 per class).</p><p>In the area of kernel methods the dominant approach for classification is based on support vector machines (SVM). SVM was designed for binary classification problems. Nevertheless, SVM can be applied to multiclass classification problems by decomposing the multiclass problem into multiple binary classification problems using common decomposing schemes such as: one-versus-all and one-versus-one.</p><p>In our opinion these approaches to multiclass classification can turn the low number of training examples only into a deeper problem. For instance, applying the one-versusone scheme in our case will generate binary classification problems with only 4 training examples. Over-fitting is then not only possible, but highly probable. For this reason we decided to use a kernel method that takes directly into account the multiclass nature of the problem.</p><p>We have chosen the kernel partial least squares (PLS) regression as the learning method <ref type="bibr" coords="4,166.97,345.02,15.77,8.64" target="#b10">[11,</ref><ref type="bibr" coords="4,182.74,345.02,11.83,8.64" target="#b12">13]</ref>. PLS has received a great amount of attention in the field of chemometrics where the number of explanatory variables exceeds the number of observations, which is also exactly the situation in our case. PLS creates uncorrelated latent components (variables) which are linear combinations of the original predictor variables, this low-dimensional representation being then used in a linear regression. The construction of latent components depends on the predictor variables, but also depends on the response variable, the latent components being created by a process of maximizing the covariance among input and output variables. For details about the method see <ref type="bibr" coords="4,449.05,428.70,15.77,8.64" target="#b10">[11,</ref><ref type="bibr" coords="4,464.82,428.70,11.83,8.64" target="#b12">13]</ref>. We have implemented the kernel PLS algorithm described in <ref type="bibr" coords="4,379.51,440.66,15.27,8.64" target="#b12">[13]</ref>.</p><p>The method has one parameter which must be tuned, the number of latent components to be extracted (the number of iterations). The use of too small or too large dimensional models (number of components) can cause under-fitting respectively overfitting. The number of components must be at most the rank of the training data matrix, so it must be smaller or equal to the number of training examples. Because the number of training examples was very small (2 examples per author) in all attribution problems we chose to use the maximum possible number of components, that is, in all classification problems we have set the number of components to be equal with the number of the training examples.</p><p>For closed-class attribution problems we have applied the PLS regression in the standard way (one-vs-all encoding): the output variable Y encodes the class of an example by a vector of -1 and +1, with +1 on the position corresponding to the example's class and for a new example the predicted label will be the position of the maximum of the predicted output Ŷ .</p><p>The decision of using kernel PLS regression for closed-class attribution problems was made after an empirical evaluation of the performance of the method and comparison of the results obtained by kernel PLS regression with that obtained by one-versus-all SVM and one-versus-one SVM. The very small number of training examples available for each competition problem made impossible a cross-validation evaluation and comparison. Fortunately, there is a data set very similar with the competition problems. This data set is "Ad-hoc Authorship Attribution Competition" (AAAC) data set <ref type="bibr" coords="5,307.05,387.67,10.58,8.64" target="#b5">[6]</ref>. AAAC data set consists of 13 problems that represents a wide variety of languages, lengths, and genres. Most of these problems are very similar with the competition problems, having many candidate authors and few examples per author for training.</p><p>We have used AAAC problems for an empirical evaluation of the performance of the kernel PLS regression, one-versus-all SVM and one-versus-one SVM. For all three methods we have used as kernel the p-spectrum normalized kernel of length 5 ( k5 ). In the case of kernel PLS regression the number of latent components was set as described above to be equal with the number of training examples. The variant of SVM we have used was a hard margin SVM. Because problems have a small number of examples and a high dimensional feature space induced by the p-spectrum kernel, the data set is separable and the best working SVM is a hard margin SVM that finds the maximal margin hyperplane. Hard margin SVM has no parameter to be set.</p><p>The results obtained by kernel PLS regression, one-versus-all SVM, and one-versusone SVM on the AAAC problems are given In Table <ref type="table" coords="5,343.35,558.88,3.74,8.64" target="#tab_0">1</ref>. For reference, in the last column for each problem is listed the best result obtained for that problem by a system participating to the competition. Note that no single system obtained the best results for all problems. The best overall result obtained in the AAAC competition is that of the highest scoring participant.</p><p>These results motivated our choice of kernel PLS regression as our entry in the competition for closed-class attribution sub-task. In the competition, kernel PLS regression obtained the highest accuracy for all problems of the closed-class attribution sub-task. class attribution sub-task. For comparison in the table are also given the results that one-versus-all SVM and one-versus-one SVM would have obtained in the competition (the evaluation was made possible by the release of ground truth data). SVM with the encoding one-vs-all was better than SVM with one-vs-one, but PLS was better than both, as predicted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Open-Class Attribution</head><p>For open-class attribution problems we need to decide when to predict a label and when not. What the kernel PLS regression returns is a vector Ŷ of real values. In the closedclass case the predicted label was the position of the maximum of Ŷ . Starting with Ŷ , a standard way to decide when to predict is to establish a threshold and predict a label only when the corresponding maximum value of Ŷ is above the threshold. This procedure can be problematic in our case because the very small number of training example imply a small number of latent components which can cause under-fitting phenomena. Indeed, there are cases when all values of Ŷ are less than 0, but the maximum of Ŷ still indicates correctly the label. We have considered that what is important is the structure of Ŷ not the actual values of Ŷ . If maximum of Ŷ is far enough from the rest of the values of Ŷ a prediction can be made, otherwise not. We have modeled "far enough" by the condition that the difference between the maximum of Ŷ and the mean of the rest of the values of Ŷ to be greater than a fixed threshold. To establish best value for this threshold we have computed the above statistic for all testing examples of the closed-class problems and have taken the value of the 20% quantile, 0.3333. Of course, it was possible to establish a separate threshold for each open-class problem based on the corresponding closed-class problem, but we preferred a unique threshold because in real life situations not every open-class task have a closed-class variant -so the approach we took is more realistic.</p><p>The results obtained with this procedure were good: 80% accuracy on the problem B, 76.47% accuracy on the problem D and 81.25% accuracy on the problem J.</p><p>These results suggest that the method deserves further investigation, especially of its connection with the outliers detection techniques.</p><p>For this subtask we have chosen the spectral clustering <ref type="bibr" coords="7,358.15,141.78,11.45,8.64" target="#b7">[8,</ref><ref type="bibr" coords="7,369.60,141.78,7.64,8.64" target="#b4">5]</ref> as the clustering method. Very briefly, the unnormalized spectral clustering algorithm works by first constructing a similarity graph from the data, computing the unnormalized Laplacian L of this graph and then finding the m eigenvectors U n×m corresponding to the m smallest eigenvalues of L (ignoring the trivial constant eigenvector corresponding to the eigenvalue 0). Using a standard method like K-means, the rows of U are clustered yielding a clustering of the original observations. For more details and justification of the method the reader is referred to <ref type="bibr" coords="7,179.02,225.47,10.79,8.64" target="#b7">[8,</ref><ref type="bibr" coords="7,189.81,225.47,7.19,8.64" target="#b4">5]</ref>.</p><p>There are a number of details that one must take care of when applying spectral clustering in practice. One must choose how to compute the similarity between observations and how to transform these similarities into a similarity graph. As similarity between observations we have used the p-spectrum normalized kernel of length 5 ( k5 ), the same as in the case of attribution. An important point in spectral clustering is to construct similarity graphs that reflect the local neighborhood relationships between observations. Starting from a similarity matrix, there are many ways to define a similarity graph that reflects local behavior. One of the most popular and the one that we have used is the mutual k-nearest-neighbor graph. In the case of the mutual k-nearestneighbor graph, the parameter k, representing the number of nearest neighbors, must be set. We have built problems similar to E and F, and by examining the performance of spectral clustering on those with different values of k, we have eventually chosen k = 12.</p><p>We have focused our efforts to solving the problem in its initial formulation, as still given on the website of the competition: in this problem you are given a text (which, for simplicity, is segmented into a sequence of "paragraphs") and are asked to cluster the paragraphs into exactly two clusters: one that includes paragraphs written by the "main" author of the text and another that includes all paragraphs written by anybody else.</p><p>For each problem our method clusters the paragraphs into exactly two clusters, even though later when the test data were released some problems consisted of paragraphs written by more than two authors and the performance of a method on these problems is measured according to the respective number of clusters.</p><p>The method behaves very well on the problems having two clusters. The results obtained on these problems are given in Table <ref type="table" coords="7,320.06,537.05,3.74,8.64" target="#tab_4">3</ref>  We have treated the sexual predator identification problem as a classification problem in which each chat participant contributes with precisely one example labeled as predator on not depending on how participant is considered. The contributions of each chat participant are joined into a single text, with line separators, all uppercase letters are converted to the corresponding lowercase ones, and consecutive white spaces are converted to a single space.</p><p>The resulted classification problem have been approached as in the previous cases with kernel based learning methods.</p><p>This time the kernel used was the character p-grams presence bits kernel (normalized) of length 5 ( k0/1 5 ). We have used 5-grams as an educated guess, as 5 is long enough to catch the ubiquitous " asl ", in general long enough to capture word stems in English, and short enough to warrant frequent-enough matches between related same-stem words. We have used this string kernel out of all possible alternatives again as an educated guess: it can be argued that identifying the predators based on the content of their chat logs is a semantic problem, therefore we have used the kernel that we know it works very well on a somewhat-related n-grams based semantic analysis problem, the network anomaly detection (often aimed at network intrusion detection). There the "signatures" are exposing the presence of the network attacks, here we hoped similarly something from what the predators write will act as a signature of their exploiting attempt. Using presence bits brings resilience to attempts of hiding the important part, the signature, by adding large quantities of normal content. Another shared feature of the predators identification problem and of network intrusion detection is the severe class unbalance (here only 142 out of the 100,000 chatters were predators).</p><p>Choosing the kernel methods and evaluating them was a difficult task taking into account the dimensions of the problem.</p><p>The resources we had at our disposal were: a 4 GB RAM dual-core machine and a 6 GB 4-core machine Note 1. While we thank here without naming them to the ones who promised us help in getting access to better computational resources, those promises failed to ever materialize -in one case, and materialized much too late -in the other case. Therefore the major technical difficulty we had was processing 80 GB kernel matrices in 4 to 6 GB RAM computers. The solution we have found for this is blocking, using matrix chunks, blocks of 5,000x5,000 elements written as independent units on disk. While this works, it works as expected very slowly, therefore we were severely limited in the set of machine learning algorithms that we could attempt.</p><p>We have computed the nearest 10 labeled neighbors for each element, by computing the top 10 labeled neighbors in each row of 5000x5000-sized blocks, then doing a postprocessing sort of the top 10 in each block. This procedure is guaranteed to produce at least 10 correct nearest neighbors. 10 was chosen as a compromise between our need to analyze the data and our limited resources. We have experimented with two methods: one based on k-Nearest Neighbors and the other based on random forests.</p><p>Method 1: k-NN (k-Nearest Neighbors) Simple statistics indicate that k-NN <ref type="bibr" coords="9,455.08,392.14,11.62,8.64" target="#b2">[3]</ref> on above representation has good chances to produce results for this problem; on the training dataset, after excluding the first neighbor (which is most of the time itself), in average 7.4859 of the first 9 neighbors of the predators are predators, whereas the mean of this statistic over the entire population is just 0.0479. We have used a variation of k-NN where we require that the first k neighbors of one sample being labeled as predators, in order to label the yet unlabeled sample as predator too. For choosing the best k we have tuned on the training data, and for k=4 we have achieved the best F-measure, 0.64 (precision=0.64, recall=0.64).</p><p>Method 2: Random forests After exploratory data analysis, consisting in examining plots of the data after various processing, we have used for our second (and better) submission random forests <ref type="bibr" coords="9,248.43,536.52,11.62,8.64" target="#b1">[2]</ref> based on a slightly different data representation: the similarity with the predators within the first 8 neighbors -from the first 8 rows of the kernel matrix; the similarity values for the non-predator neighbors are set to 0. Please note that the previous representation can be computed from this one (by ignoring the precise similarity values and counting only the non-zero values) which contains therefore more information.</p><p>The plot of the data in Figure <ref type="figure" coords="9,274.88,608.43,4.98,8.64" target="#fig_0">1</ref> shows that this representation not only separates fairly nicely the predators from the normal population, but suggests also the existence of a structure / clusters in the set of predators.</p><p>Random forests method provides on the training dataset a different balance of about the same recall (0.67) and higher precision (0.77), for seemingly even higher F-measure  (0.72). The results on the test dataset were close to that: recall=0.64, precision=0.74, F-measure=0.69. As a note concerning the use of random forest on this classification, we look here at the variability of the prediction accuracy due to the implied in the building of the random forests model. As shown in Figure <ref type="figure" coords="10,342.66,380.43,4.98,8.64" target="#fig_1">2</ref> the performance to be expected on the test set is fairly stable, despite the randomness implied in the random forests training.</p><p>To convince the reader that the n-grams binary embedding (with bits of presence) leads to a better kernel for this problem than the spectrum kernel, for n-grams of the same length (5), we have recomputed after the competition the kernel matrix, using the normalized spectrum kernel (which, we remind, uses the frequency of the n-grams in embedding, instead of their mere presence). The 5-fold cross-validation results for the same 100 trees random-forest model were as we had expected, considerably worse: recall=0.49, precision=0.76, and thus F-measure=0.60.</p><p>Interestingly, when raising the number of neighbors considered from 8 (used in our solution because of the very limited computing resources available to us at the time of this competition) to 16, there is a slight increase in the performance: recall=0.52, precision=0.79, F-measure=0.63.</p><p>One could conclude here that indeed the binary kernel is simply better than the spectrum kernel for this type of problems. Still, there is something interesting about the recall achievable with k-NN when using the spectrum kernel. As shown in figure <ref type="figure" coords="10,473.11,572.49,3.74,8.64" target="#fig_2">3</ref>, when deciding only on the first neighbor (1-NN), the recall is close to 0.9</p><p>Leveraging the capability of random forests to employ just the information contained in the useful inputs and to a large extent to ignore the useless / noise-containing ones, we have tried also to combine the two kernels instead of deciding which one is the best and selecting one. And indeed, by using as inputs to the machine learning problem the similarities to the predators in the first 8 neighbors for each of the two kernels, the 5-fold cross-validation performance increased sensibly over our best so far, show- ing once again the benefits of multiple kernel learning: recall=0.75, precision=0.83, F-measure=0.79.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Predators Lines Identification</head><p>There was also a second sub-task, where the very lines that prove the sexual predator's quality were to be found. As this was compulsory, we had to send something. A cursory examination of some of the training examples has shown us that there was no word wasted in their attempt to get alone with the future victim as soon as possible. Even the apparently innocent parts of the chat served a purpose. Therefore, we chose to simply mark as suspect all chat lines of the users we have identified (correctly or wrongly) as predators. Surprisingly this brought us a very good position (2 nd !) with very high recall and poor accuracy, position that eventually turned into 1 st after more after-thefact tinkering with the scoring functions by the organizers (see the authorship clustering issue as well).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have presented in this article our approaches to a rather diverse set of problems: the style-oriented closed-class and open-class attribution, authorship clustering / intrinsic plagiarism and the semantically-oriented sexual predators identification. As a result, we have used a variety of machine learning methods: kernel partial least squares (PLS), spectral clustering and random forests. What is shared in all these is our languageindependent NLP-techniques light approach of building string kernels based on characterlevel n-grams (either spectrum or its binary embedding correspondent, where the frequencies are replaced by presence bits), followed by the application of state of the art machine learning techniques. It is interesting to note that we have chosen the ML techniques not as much through extensive evaluation on the few data available for training as by their intrinsic qualities in what concerns the probability of over-fitting and the known success in parallel fields (such as chemometrics or computer networks security). The results were extremely good, we ranked first in most problems and overall in the traditional authorship attribution task, according to the evaluation provided by the organizers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="9,134.77,300.65,345.82,8.12;9,134.77,311.96,195.01,7.77;9,305.44,322.92,2.24,7.77"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Classes distribution in the chosen representation; the lower-dimensional plot is obtained by retaining the three most important PCA projections .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="10,166.12,300.65,283.11,8.12;10,305.44,311.96,2.24,7.77"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Stability of the accuracy of the RF solution measured on the test data .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="11,156.90,300.65,301.56,8.12;11,305.44,311.96,2.24,7.77"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Balancing precision and recall with k-NN when using the spectrum kernel .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="5,134.77,117.72,345.83,194.13"><head>Table 1 .</head><label>1</label><figDesc>The results obtained by kernel PLS regression, one-versus-all SVM, and one-versus-one SVM on the AAAC problems .</figDesc><table coords="5,161.49,117.72,292.39,162.34"><row><cell cols="2">Problem PLS</cell><cell cols="3">SVM (ova) SVM (ovo) Best result in the competition</cell></row><row><cell>A</cell><cell cols="2">76.92% 84.62%</cell><cell>69.23%</cell><cell>84.62%</cell></row><row><cell>B</cell><cell cols="2">53.85% 38.46%</cell><cell>38.46%</cell><cell>53.85%</cell></row><row><cell>C</cell><cell cols="2">100.00% 88.89%</cell><cell>88.89%</cell><cell>100.00%</cell></row><row><cell>D</cell><cell cols="2">75.00% 50.00%</cell><cell>50.00%</cell><cell>100.00%</cell></row><row><cell>E</cell><cell cols="2">25.00% 25.00%</cell><cell>25.00%</cell><cell>100.00%</cell></row><row><cell>F</cell><cell cols="2">90.00% 90.00%</cell><cell>90.00%</cell><cell>100.00%</cell></row><row><cell>G</cell><cell cols="2">50.00% 50.00%</cell><cell>50.00%</cell><cell>75.00%</cell></row><row><cell>H</cell><cell cols="2">100.00% 33.33%</cell><cell>33.33%</cell><cell>100.00%</cell></row><row><cell>I</cell><cell cols="2">75.00% 50.00%</cell><cell>50.00%</cell><cell>100.00%</cell></row><row><cell>J</cell><cell cols="2">100.00% 50.00%</cell><cell>50.00%</cell><cell>100.00%</cell></row><row><cell>K</cell><cell cols="2">50.00% 50.00%</cell><cell>50.00%</cell><cell>75.00%</cell></row><row><cell>L</cell><cell cols="2">75.00% 75.00%</cell><cell>50.00%</cell><cell>100.00%</cell></row><row><cell>M</cell><cell cols="2">75.00% 75.00%</cell><cell>75.00%</cell><cell>87.50%</cell></row><row><cell>Overall</cell><cell cols="2">72.75% 58.48%</cell><cell>55.38%</cell><cell>70.61%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="5,134.77,656.44,345.82,8.64"><head>Table 2</head><label>2</label><figDesc>presents the results obtained by our method for each problem in the closed-</figDesc><table coords="6,222.20,117.72,170.96,52.76"><row><cell cols="2">Problem PLS</cell><cell cols="2">SVM (ova) SVM (ovo)</cell></row><row><cell>A</cell><cell cols="2">100.00% 100.00%</cell><cell>83.33%</cell></row><row><cell>C</cell><cell cols="2">100.00% 62.50%</cell><cell>50.00%</cell></row><row><cell>I</cell><cell cols="2">92.86% 78.57%</cell><cell>71.43%</cell></row><row><cell>Overall</cell><cell cols="2">97.62% 80.36%</cell><cell>68.25%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="6,134.77,183.17,345.82,19.08"><head>Table 2 .</head><label>2</label><figDesc>The results obtained by kernel PLS regression, one-versus-all SVM and one-versus-one SVM for closed-class attribution sub-task problems</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" coords="7,184.65,537.05,246.06,95.08"><head></head><label></label><figDesc>.</figDesc><table coords="7,184.65,568.82,246.06,63.32"><row><cell>Problem</cell><cell cols="2">No. of paragraphs Paragraphs correctly clustered</cell></row><row><cell>Etest01</cell><cell>30</cell><cell>30 (100.00%)</cell></row><row><cell>Ftest01</cell><cell>20</cell><cell>20 (100.00%)</cell></row><row><cell>Ftest02</cell><cell>20</cell><cell>19 (95.00%)</cell></row><row><cell>Ftest03</cell><cell>20</cell><cell>16 (80.00%)</cell></row><row><cell>Ftest04</cell><cell>20</cell><cell>20 (100.00%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" coords="7,149.84,644.83,315.69,8.12"><head>Table 3 .</head><label>3</label><figDesc>The results obtained by spectral clustering on the problems having two clusters</figDesc><table coords="8,134.77,117.55,171.81,35.87"><row><cell>5 Sexual Predator Identification</cell></row><row><cell>5.1 Predators Identification</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0" coords="3,144.73,635.17,335.86,7.77;3,144.73,646.13,335.86,7.77;3,144.73,657.08,64.74,7.77"><p>Note that the notion of substring requires contiguity. See<ref type="bibr" coords="3,354.28,635.17,14.94,7.77" target="#b12">[13]</ref> for a discussion about the ambiguity between the terms "substring" and "subsequence" across different traditions: biology, computer science.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="12,142.61,246.49,332.79,7.77;12,150.95,257.45,269.31,7.77;12,150.95,268.40,111.95,7.77" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="12,235.18,246.49,240.22,7.77;12,150.95,257.45,40.81,7.77">Overview of the international authorship identification competition at pan-2011</title>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Argamon</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Juola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,357.76,257.45,62.51,7.77;12,150.95,268.40,81.72,7.77">CLEF (Notebook Papers/Labs/Workshop</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Petras</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Forner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Clough</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.61,279.36,250.40,7.77" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="12,198.77,279.36,55.51,7.77">Random forests</title>
		<author>
			<persName coords=""><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,259.78,279.36,63.00,7.77">Machine learning</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="32" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.61,290.32,313.51,7.77;12,150.95,301.28,131.42,7.77" xml:id="b2">
	<analytic>
		<title level="a" type="main" coord="12,219.65,290.32,136.67,7.77">Nearest neighbor pattern classification</title>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Cover</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,361.83,290.32,94.29,7.77;12,150.95,301.28,56.71,7.77">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="27" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
	<note>Information Theory</note>
</biblStruct>

<biblStruct coords="12,142.61,312.24,324.91,7.77;12,150.95,323.20,299.42,7.77;12,150.95,334.16,304.66,7.77" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="12,277.96,312.24,189.57,7.77;12,150.95,323.20,135.20,7.77">ENCOPLOT: Pairwise Sequence Matching in Linear Time Applied to Plagiarism Detection</title>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Grozea</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Gehl</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Popescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,304.31,323.20,146.07,7.77;12,150.95,334.16,51.52,7.77">UNCOVERING PLAGIARISM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
	<note>3rd PAN WORKSHOP</note>
</biblStruct>

<biblStruct coords="12,142.61,345.12,325.40,7.77;12,150.95,356.08,174.69,7.77" xml:id="b4">
	<monogr>
		<title level="m" type="main" coord="12,292.93,345.12,175.08,7.77;12,150.95,356.08,85.88,7.77">The elements of statistical learning: data mining, inference and prediction</title>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Hastie</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Friedman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>2 edn.</note>
</biblStruct>

<biblStruct coords="12,142.61,367.03,321.57,7.77;12,150.95,377.99,57.53,7.77" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="12,185.34,367.03,78.72,7.77">Authorship attribution</title>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Juola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,269.58,367.03,175.18,7.77">Foundations and Trends in Information Retrieval</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="233" to="334" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.61,388.95,302.27,7.77;12,150.95,399.91,305.72,7.77;12,150.95,410.87,23.90,7.77" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="12,429.21,388.95,15.67,7.77;12,150.95,399.91,117.94,7.77">Text classification using string kernels</title>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Lodhi</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Saunders</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Shawe-Taylor</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>Cristianini</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">J C H</forename><surname>Watkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,274.65,399.91,139.44,7.77">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="419" to="444" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.61,421.83,322.56,7.77;12,150.95,432.79,23.90,7.77" xml:id="b7">
	<analytic>
		<title level="a" type="main" coord="12,199.43,421.83,112.37,7.77">A tutorial on spectral clustering</title>
		<author>
			<persName coords=""><forename type="first">U</forename><surname>Luxburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,317.46,421.83,90.17,7.77">Statistics and Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="395" to="416" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.61,443.75,301.33,7.77;12,150.95,454.71,306.80,7.77;12,150.95,465.66,298.50,7.77" xml:id="b8">
	<analytic>
		<title level="a" type="main" coord="12,200.26,443.75,159.28,7.77">Studying translationese at the character level</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Popescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,377.21,443.75,66.74,7.77;12,150.95,454.71,270.94,7.77;12,186.82,465.66,131.58,7.77">Proceedings of the International Conference Recent Advances in Natural Language Processing</title>
		<meeting>the International Conference Recent Advances in Natural Language Processing<address><addrLine>Hissar, Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-09">2011. September 2011</date>
			<biblScope unit="page" from="634" to="639" />
		</imprint>
	</monogr>
	<note>RANLP 2011 Organising Committee</note>
</biblStruct>

<biblStruct coords="12,142.24,476.62,326.44,7.77;12,150.95,487.58,306.26,7.77;12,150.95,498.54,317.21,7.77;12,150.95,509.50,20.92,7.77" xml:id="b9">
	<analytic>
		<title level="a" type="main" coord="12,241.12,476.62,227.56,7.77;12,150.95,487.58,91.57,7.77">Kernel methods and string kernels for authorship identification: The federalist papers case</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">L</forename><forename type="middle">P</forename><surname>Dinu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,260.51,487.58,196.71,7.77;12,150.95,498.54,199.46,7.77">Proceedings of the International Conference on Recent Advances in Natural Language Processing (RANLP-07)</title>
		<meeting>the International Conference on Recent Advances in Natural Language Processing (RANLP-07)<address><addrLine>Borovets, Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-09">September 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.24,520.46,336.17,7.77;12,150.95,531.42,228.09,7.77" xml:id="b10">
	<analytic>
		<title level="a" type="main" coord="12,237.31,520.46,241.09,7.77;12,150.95,531.42,18.46,7.77">Kernel partial least squares regression in reproducing kernel hilbert space</title>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Rosipal</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">L</forename><forename type="middle">J</forename><surname>Trejo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,175.35,531.42,139.44,7.77">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="97" to="123" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.24,542.38,330.73,7.77;12,150.95,553.34,326.94,7.77;12,150.95,564.29,294.86,7.77;12,150.95,575.25,206.76,7.77" xml:id="b11">
	<analytic>
		<title level="a" type="main" coord="12,250.46,542.38,222.51,7.77;12,150.95,553.34,167.38,7.77">Short text authorship attribution via sequence kernels, markov chains and author unmasking: An investigation</title>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Sanderson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Guenter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,336.21,553.34,141.69,7.77;12,150.95,564.29,184.53,7.77">Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2006 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2006-07">July 2006</date>
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,142.24,586.21,324.96,7.77;12,150.95,597.17,124.63,7.77" xml:id="b12">
	<monogr>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">S</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>Cristianini</surname></persName>
		</author>
		<title level="m" coord="12,251.50,586.21,130.13,7.77">Kernel Methods for Pattern Analysis</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
