<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,89.29,84.74,360.66,15.42;1,89.29,106.66,383.02,15.42">A Search Engine System for TouchÃ© Argument Retrieval task to answer Controversial Questions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,89.29,134.97,90.57,11.96"><forename type="first">Edoardo</forename><surname>Raimondi</surname></persName>
							<email>edoardo.raimondi@studenti.unipd.it</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Padua</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,192.84,134.97,69.38,11.96"><forename type="first">Marco</forename><surname>Alessio</surname></persName>
							<email>marco.alessio.1@studenti.unipd.it</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Padua</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,293.55,134.97,77.51,11.96"><forename type="first">Nicola</forename><surname>Levorato</surname></persName>
							<email>nicola.levorato.2@studenti.unipd.it</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Padua</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Computer Engineering&quot;</orgName>
								<orgName type="department" key="dep2">Department of Information Engineering</orgName>
								<orgName type="institution">University of Padua</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,89.29,84.74,360.66,15.42;1,89.29,106.66,383.02,15.42">A Search Engine System for TouchÃ© Argument Retrieval task to answer Controversial Questions</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1613-0073</idno>
					</monogr>
					<idno type="MD5">CD033B78CA54EE302F6A17DFEE339B8B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T16:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>TouchÃ¨ 2021</term>
					<term>Argument Retrieval</term>
					<term>Search Engines</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a search engine system capable of retrieving relevant arguments inside a controversial questions forum. Our focus is on processing the corpus, indexing the collection and searching for each query while also addressing the document quality problem implementing a machine learning approach. Furthermore, we provide a brief evaluation of our retrieval results based on 2020 topics for the TouchÃ© Argument Retrieval task.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="13" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="14" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="15" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="16" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="17" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
		<surface n="18" ulx="0.0" uly="0.0" lrx="595.276" lry="841.89"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>This report has the aim to describe the project developed for the Search Engines course 2020/21 of the University of Study of Padua, by accompanying the reader through our system in a path of increasing specificity. The task of the homework is the TouchÃ© Argument Retrieval for Controversial Questions. The goal of this task is to support users who search for arguments to be used in conversations (e.g., getting an overview of pros and cons or just looking for arguments in line with a user's stance). Given a question on a controversial topic, the task is to retrieve relevant arguments from a focused crawl of online debate portals.</p><p>The paper is organized as follows: Section 2 introduces related works; Section 3 describes our approach; Section 4 explains our experimental setup; Section 5 discusses our main findings and reports a statistical analysis on the 2020 edition data; finally, Section 6 draws some conclusions and outlooks for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>The baseline that literature provides us for this specific Controversial Questions retrieval, is composed by the usage of BM25, TF-IDF, DPH.</p><p>Successful works (from 2020 edition) instead, tried to go further. They considered and managed also:</p><p>1. query expansion (WordNet synonyms/ antonyms -&gt; GPT-2 generation); 2. document representation using transformers; 3. re-ranking on argument quality prediction; 4. re-ranking based in sentiment (neutral sentiment); 5. pseudo-relevance feedback.</p><p>Even if all of those points are essential in order to provide a noteworthy system, in this case we will focus on query expansion and re-ranking on argument quality prediction. It will then follow a statistical and performance analysis of the chosen approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Methodology</head><p>The general structure of our search engine system can be nimbly divided into 6 parts, which corresponds to a different package in our source code. In particular each component has a different aim:</p><p>1. parsing corpus files and extracting documents; 2. analyze input documents to extract tokens; 3. build the index; 4. searching for each provided topic; 5. provide a linear classification of the retrieved documents; 6. provide different classes to execute the main functions of the project.</p><p>The details of each of them are separately reported in the following pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Parsing</head><p>The parsing part of our system is implemented in the package named "parse". This section contains the ToucheParser class used to parse every JSON corpus file inside the corpus directory of the project. The parsing is done using the help of the Gson library that deserialize the args.me corpus in a streaming fashion. This is mandatory since the files are too large to be fitted in the main memory for the parsing. When an object instance of the ToucheParser class is created, the constructor takes the path to the corpus file and it is deserialized using a JsonReader that is the GSON streaming JSON parser. Then the class implements some basic methods like the iterator, hasNext and next functions used to access between the parsed documents.</p><p>While parsing the files of the corpus, the ToucheParser extract each document from the JSON structure converting them into a ToucheDocument object. This class contain the most relevant fields (like the id, the text, the conclusion) that are common in each document of the corpus and a method used to convert the object into an object instance of the ParsedDocument class that is the one used to represent a document inside all other sections. The ParsedDocument class represents a parsed document to be indexed in fact it contains two main fields:</p><p>1. the id: is the unique identifier contained in each document of the corpus; 2. the body: is composed by appending each other relevant field of the document (like the conclusion and the text in the premise) into a single string if they are not null.</p><p>The following figure represent an example of a document in JSON format inside the corpus file "parliamentary.json". The three fields highlighted are the ones that are extracted during the parsing. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Analyze</head><p>The analyze part of our system is implemented in the package named "analyze". This section contains the analyzer used to parse each document of the corpus and produce for each of them the corresponding stream of tokens. The first phase for our analyzer is to try to filter out all junk data from the documents text.</p><p>In the final version of the project, we found that the best compromise between quality of the results and time spent was to just discard all links through a regular expression matching filter.</p><p>Then tokenization takes place, which splits the stream of text in tokens in correspondence of white spaces and the most used punctuation characters. Then we remove all possessive forms ('s) from the end of each token and we transform them in lowercase.</p><p>The second-last phase uses a stop list in order to discard the most frequent english words from each document, that would be of no use later during indexing and searching. At the end we apply a discard filter that aims to remove all tokens that contains non letter characters.</p><p>The processing done by our analyzer is very basic. During the development phase, a more advanced analyzer has been deployed; it was aimed to group together in a single token multiple words that together forms a unit with a specific meaning different from the one of the single words (i.e. "get" and "up" are fused together in "get up"). Because of the lack of results improvements during searching and the very tight project deadline, we have run out of time to further developing it and so we were forced to drop it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Indexing</head><p>The indexing part of our system is implemented in the package named "index". It does exactly what a standard Lucene indexer do. It is based on two classes:</p><p>1. ToucheIndexer class: It builds the index inside the experiment/index folder.</p><p>It uses the ToucheParser class described before to extract documents from the corpus files and remove any duplicate with an HashSet. Since there are some short documents in the collection that are not relevant, all documents with a number of characters in the body less than a fixed number (in our case 10 character) are discarded.</p><p>The ramBuffer size used is 256. Among a few similarity functions tested, BM25 seemed to be the best one for our case; 2. BodyField class: It represents a Lucene field for containing the body of a document.</p><p>It's also used to set or enable some option like the term vectors.</p><p>It is important to mention that the analyzer used in this section, whose details are described in the previous paragraph, is the same used for searching purpose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Searching</head><p>The searching part of our system is implemented in the package named "search". The class ToucheSearcher performs all tasks related to search. For each topic, we use our analyzer to obtain the corresponding stream of tokens that represent it. With them, we can build the query which Lucene uses to retrieve a list of documents relative to the topic.</p><p>In order to get better results we perform query expansion: we add to the query, for each token:</p><p>â€¢ similar forms of the word (e.g. conjugation of verbs, plurals of names, ...), with a total relative weight of 50% c.a.</p><p>â€¢ synonyms of the word, with a total relative weight of 50% c.a.</p><p>â€¢ antonyms of the word, with a total relative weight of 20% c.a.</p><p>With total relative weight we mean the sum of the individual weight of the words added; note that they are all the same in our current implementation.</p><p>The dictionary used in this phase is an ad-hoc modified version of the freely-available Word-Net database (available at: https://wordnet.princeton.edu/, it uses its own "WordNet 3.0" license that allows to freely use, copy, modify and distribute it without fee or royalty) obtained by discarding all synsets that are formed by more than a single word.</p><p>In order to parse the topic xml files that contains all the query to be searched we developed a specific class : XmlTopicsParser. It extract each query from a topic xml file using the DOM API that create an in-memory representation of the xml. It returns a QualityQuery array containing all the query parsed.</p><p>Once the desired number of documents has been retrieved by our search function, we then applied machine learning subroutine to all of them. (At the beginning it was considered to apply machine learning only on the top n retrieved documents, but this decision should be made in light of the assumption that the first n documents are all relevant with respect to the current query. This assumption can't be applied in our case since our system is not good enough to ensure such a strong assumption.) Given this premise, since we are not circumscribed in a binary relevance judgment, it is necessary to consider and evaluate several aspects. Among all these possible aspects, in this specific subroutine, we are going to take care of the general writing quality. Basically we are not confident in saying that the first n documents are relevant and it becomes challenging at this point to understand how much relevant, in term of quality, a document is. In order to try to reach an acceptable bound in these terms, a linear regression model has been trained. The training part has been object of interesting considerations that is worth describing separately. (see Section 3.5). Suppose we now have our run with all the k documents. We let our pre-trained model classify each of them and save the corresponding predicted quality in a dictionary data structure. The next step is to provide a final score that mix the BM25 searching score and the machine learning score. There are several way to do it but our choice (made upon measure evaluation, see section 5) has fallen in the weighted average between the two scores. Once done it, the run is "re-write" as an output, according to the new scores (i.e. weighted average).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Linear Regression</head><p>It is implemented inside the package called "linear regression". For this purpose we leaned on the machine learning library called "weka". TouchÃ¨ organizers provides us a dataset of arguments with relative labels including one named "Combined Quality". This feature describes the combination of rhetorical, logical and dialectical quality of a specific arguments and we are going to use it as a label for the training part. The general pipeline is : train a linear regression model, classify all the retrieved documents and reorder them by mixing the predicted quality score by our model and the BM25 score (as described in section 3.4).</p><p>The training of the model has been performed as follow:</p><p>1. Document vectorization (both for training set and fresh data) 2. Fitting 3. Evaluation Since the last two steps are quite standard, we will stress our explanation on the first operation.</p><p>The application of the model on our system is done, and already exposed, in the searching part.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1.">Document vectorization</head><p>To represent complex sentences as a vector of numbers, literature provide us a large amount of techniques. Both for lack of time and experience on this field, the chosen workflow is one of the simplest but it works properly.</p><p>First at all documents passed trough an ad-hoc customized Lucene analyzer, which applied stop word removal (with the same stop list used for the corpora to ensure more compatibility), stemming and filtering based on word lengths. We encapsulate the k most frequent words of a given domain (e.g. entire training set or set of retrieved document i.e. fresh samples to classify) in a general vector ğ‘šğ‘œğ‘ ğ‘¡ğ¹ ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘’ğ‘›ğ‘¡ğ‘Šğ‘œğ‘Ÿğ‘‘ğ‘ . Then we need to encode each document (in this specific case a multi hot encoding is performed).</p><p>To do it, we constructed a vector ğ‘£ of size k+1. We set 1 or 0 the cell ğ‘– if the document contains the ğ‘–-th most frequent word. (e.g. ğ‘£[0] = 1 if the document contains the most frequent word, 0 otherwise, and so on). After this step only k cell of mt vector ğ‘£ will be filled. Finally in the last position we set the "Combined quality" feature in order to use it as a label. ( Note: even in the classification part this k+1-th element need to be present, even if it will not obviously be consider. The reason why weka required that is still a mistery... ) All the vectors (i.e. the documents) are stored in csv files. This is done to facilities the communication between our code and weka functions, since they load data via files of this type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2.">Fitting and Evalutation</head><p>In order to fit and evaluate our model, we took our pre-vectorized training set and we split it in training and test set. Once fitted our model on the training set, we evaluate it using least mean squared error as loss function. The evaluation helps us to tune the hyperparameters of document vectorization in the best possible way. The most important parameters were: which stop list to use, how many most frequent word to consider and the usage of the absolute frequency instead of other possible metrics.</p><p>All this work is done by different classes, as good modular programming required, which names are self-descriptive: CSVCleaner, RegressionAnalyzer, CSVWriter, Encoder, ToucheRegression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Execution</head><p>The package "exec" has been made thinking outside the pure information retrieval purpose, but it is more a child of a software engineering point of view. This section contains all the executable classes of the project and it is used mainly for debugging purpose. For example the Indexing class is used to build the index in the experiment directory, the Parsing class is used to get a look of the documents extracted from a chosen corpus file and the Searching class is used to build the runs.</p><p>All the corpus files should be placed inside a corpus directory, the directory experiment contains the index and the run files and all the topic xml files should be inside a topics directory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experimental Setup</head><p>Our experimental set up is made upon:</p><p>â€¢ as documents collection we used the args.me corpus (version 2020-04-01) available at https://zenodo.org/record/3734893#.YIxOLbUzaUk</p><p>â€¢ as evaluation data we used the 2020 topics available at https://webis.de/events/touche-21/ shared-task-1.html#data</p><p>â€¢ as evaluation measures we massively used NCGD (because it is the same used in the 2020 touche results) but without forgetting to think about precision, recall, average precision and all the measures provided by trec eval program.</p><p>â€¢ the url of our git repository is https://bitbucket.org/upd-dei-stud-prj/seupd2021-mr/src/ master/</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Results and Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Results of our system</head><p>The score provided by Lucene and the BM25 similarity judges only the relevance of a document, without considering the overall quality of it, such as the writing style and the length. On the other hand, the score provided only by Machine Learning takes care only of the general writing quality. Therefore we have decided that combining the two scores could get better results.</p><p>In order to do so, first we have to make both scores comparable, by normalizing them in the [0.0, 1.0] range using this formula:</p><formula xml:id="formula_0" coords="8,216.38,235.90,289.61,25.34">ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ ğ‘›ğ‘œğ‘Ÿğ‘šğ‘ğ‘™ğ‘–ğ‘§ğ‘’ğ‘‘ = ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ -ğ‘šğ‘–ğ‘› ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ ğ‘šğ‘ğ‘¥ ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ -ğ‘šğ‘–ğ‘› ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (1)</formula><p>Then we proceed by applying a linear combination to them. We used a factor ğ‘ğ‘™ğ‘â„ğ‘ in the range [0.0, 1.0] to weight the score given by BM25 similarity and 1 -ğ‘ğ‘™ğ‘â„ğ‘ to weight the score given by the machine learning approach. The formula we used to combine the two score is the following:</p><formula xml:id="formula_1" coords="8,150.32,336.02,355.66,11.79">ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ ğ‘šğ‘–ğ‘¥ğ‘’ğ‘‘ = ğ‘ğ‘™ğ‘â„ğ‘ * ğ‘›ğ‘œğ‘Ÿğ‘šğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ ğµğ‘€25 + (1 -ğ‘ğ‘™ğ‘â„ğ‘) * ğ‘›ğ‘œğ‘Ÿğ‘šğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ ğ‘€ğ¿ (2)</formula><p>If the value of ğ‘ğ‘™ğ‘â„ğ‘ is within the range [0.5, 0.8], the quality of the run increases w.r.t the two pure approaches (pure BM25 at ğ‘ğ‘™ğ‘â„ğ‘ = 1.0, pure ML at ğ‘ğ‘™ğ‘â„ğ‘ = 0.0), reaching the best results at about 0.6 (we choose to use NDCG@5 as metric of choice because is the one used in TouchÃ© 2020 results), as shown in Figure <ref type="figure" coords="8,273.46,401.18,3.74,10.91" target="#fig_1">2</ref>. This means that the BM25 score should be higher weighted w.r.t ML score, that is the relevance judgement is more important than the writing quality of the documents. From our tests we saw that all major measure values of the run increases using this mixed approach: by keeping the top 30 of the 1000 documents initially retrieved we found the table in Figure <ref type="figure" coords="8,131.96,647.05,3.74,10.91" target="#fig_2">3</ref>. For all our test we have used vectors of size 250 (i.e. max number of most frequent words) to train the linear regression model. Our test shows that changes in the number of most frequent words considered has almost no impact on the NDCG@5 measure, as shown in figure <ref type="figure" coords="9,469.62,289.95,3.74,10.91" target="#fig_3">4</ref>. In the final version of our code, we decided to stick with the top 250, because the impact on runtime is still negligible and it should provide a more robust solution compared to using a lower number of words. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Results of our system compared to TouchÃ© 2020 best system</head><p>For this comparison, we chose from TouchÃ© 2020 runs (available at https://webis.de/events/ touche-21/runs-task-1-2020.zip, dataset v2) the one with the highest average NDCG@5 measure. The chosen run is "DirichletLM" by team "Swordman", against a run obtained from our system using ğ‘ğ‘™ğ‘â„ğ‘ = 0.6.</p><p>Since both runs retrieve 1000 documents for each topic, the first metric we decided to analyze is the recall for each topic. As we can see in Figure <ref type="figure" coords="9,316.94,622.85,3.74,10.91" target="#fig_4">5</ref>, our system performs significantly better as shown by the average recall: 0.8637 and 0.7693. Although the higher recall, the Figure <ref type="figure" coords="10,267.68,280.25,5.07,10.91">6</ref> shows that our systems performs significantly worse w.r.t "Swordman" run when we consider the NDCG@5 metric (average NDCG@5: 0.6184 and 0.8266). From this data, we can conclude that our system retrieves more significant documents but it ranks them poorly: in order to achieve higher results, efforts should be focused in this aspect.</p><p>Figure <ref type="figure" coords="10,229.64,539.69,3.82,10.91">6</ref>: NDCG@5 of all 49 topics of both runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Statistical analysis</head><p>In order to better understand the behavior and the meaning of our results a proper statistical analysis is needed. Our main goal is to ensure, with much confidence as possible, the improvement of our approach with respect to a basic BM25 approach. We computed 5 different runs: 1 using only BM25 and 4 adding also machine learning and changing some parameters according to what already said in section 5. Each run is represented by a 49 length array ğ‘£ (since we have 49 topics) and each elements of this array is a measure score for that topic. (i.e. ğ‘£[1] = AP of topic 1). Specifically we will consider in our analysis the average precision and NDCG@5. Now let's have a look to our data in a more formal way. Then we will continue our investigation via hypothesis testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Data visualization</head><p>First at all we start with average precision. A first overview is essential to give us a general informal taste of our data. Before doing any consideration, let's clarify the notation. The 3 central columns represent runs with different weights scoring as already explained in section 5 (see Figure <ref type="figure" coords="11,454.21,476.70,3.57,10.91" target="#fig_1">2</ref>). Jolly instead is a run with slightly different searching parameters. This is done to check the variance of our machine learning model. (i.e. we expect it to be similar to the other machine learning runs). Finally Baseline BM25 is self descriptive. Now consider a box plot representation. This first plot give us a preliminary intuition about the scenario. It is indeed visible that there is a better behaviour of machine learning runs.</p><p>Another useful representation can be done using stripcharts. Here the visualization of the outliners is more evident and let us performs some considerations. Even if Baseline BM25 reaches higher AP scores, it reaches it in isolation, while, Mixed and jolly run provide a more dense higher scores. Also the points with more density for BM25 stand in a very low score area. This suggest us that the two main systems (baseline and machine learning) are different, in particular, the last one provides better results.</p><p>Exactly same considerations can be conducted looking at NDCG@5 as scoring measure, instead of average precision.   This informally gives us more confidence about our principal intuition (i.e. there is an improvement adding our machine learning subroutine to baseline BM25). We need to better formalize it via hypothesis testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Hypothesis testing</head><p>Now let's validate our assumptions using more sophisticated statistical analysis technique such as hypotesis testing and t-test. As we stated before we are now intent on verifying the actual differences between our systems (i.e. runs). In order to do that it is necessary to correctly formalize the null and the alternative hypothesis and define a suitable significant level ğ›¼.</p><p>Hypothesis are:</p><p>1. H0 : the two runs are not different (i.e. are sampled from the same distribution); 2. H1 : the two runs are different (i.e. are sampled from different distributions).</p><p>Confidence level ğ›¼ = 0.05.</p><p>A t-test has been performed between every possible combination of our 5 runs. We expect baseline BM25 to be significantly different with respect to machine learning ones (i.e. reject null hypothesis). While it is reasonable to see that the ones with machine learning are equal to each other (i.e. fail to reject null hypothesis).</p><p>Let's now take a look to the p-value results of our t-test calculated both on average precision and NDCG@5. They will be represented by a matrix ğ‘¡. The runs are respectively baseline BM25, Mixed 0.57, Mixed 0.6, Mixed 0.62, Jolly. Of course the matrix ğ‘¡ is populated only on the top diagonal area since t-test(X, Y) = t-test(Y, X). Particularly attention has to be made upon the first row. It indeed represents the test between the baseline and all the other systems. All the p-values on ğ‘¡[1, âˆ¶] are significantly below our significant level (i.e. ğ‘¡[1, âˆ¶] &lt; ğ›¼). This validate our preliminary assumptions and it tells us that adding a machine learning subroutine provides different (and better, looking at the data) results. It also suggest us that we could decrease a lot our confidence level without affecting the final statement. So we reject null hypothesis. Another important confirmation arrives from the analysis of rows 2,3 and 4. They contain the p-values across system using machine learning but with different hyperparameters. In particular p-values are above to ğ›¼. We can conclude that we fail to reject the null hypothesis in this case. In terms of our system this means, no matter which hyperparameters one choose, the subroutine will provide results sampled from an unique distribution. Finally, the fact that all these results are valid for both measures (i.e. average precision and NDCG@5) gives us even more certainty about our beliefs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Failure analysis</head><p>A little bit of failure analysis has been performed. Both for lack of time and workforce, we considered only one topic, that is the worst case topic (i.e. it reaches 0.000 on NDCG@5). Let's have a look to it: &lt;topic&gt; &lt;number&gt;12&lt;/number&gt; &lt;title&gt;Should birth control pills be available over the counter?&lt;/title&gt; &lt;description&gt; The easy access to birth control pills may have repercussions on people's everyday behavior in taking precautions, while disregarding negative side effects. A user wonders whether birth control pills should be prescription drugs, so that doctors have a chance of explaining them to their users. &lt;/description&gt; &lt;narrative&gt; Highly relevant arguments argue for or against the availability of birth control pills without prescription. Relevant arguments argue with regard to birth control pills and their side effects only. Arguments only arguing for or against birth control are irrelevant. &lt;/narrative&gt; &lt;/topic&gt; Faced with this topic, our system mainly returned general discussion about arguing for or against birth control, that is exactly what we do not wanted to retrieve (as specified in the narrative). This could be due to the fact that in order to totally understand the topic it is absolutely necessary to give maximal importance to the description field. Our system instead, unfairly favors the words in the title, giving them much greater weights with respect to words in the description fields. In order to solve this situation a dynamic weights assignment could be developed. However, looking at the runs of the previous year, it turned out this topic to be really tough for everybody. This surely does not resolve our problem but how we say in Italy: "mal comune, mezzo gaudio".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Future Work</head><p>To conclude, our works has enlighten different ways to pursue and manage in order to deal with human made documents in a forum scenario. Indeed this scenario is very challenging, due to the document corpus presenting a lot of both intra and inter documents noise. (e.g. entire completely useless documents or document bodies full of bad written argument).</p><p>Given all the technical results already provided in the previous sections, we can claim that most of the easily achievable improvements lies on developing a better documents ranking system. The things that have to be considered when trying to improve it are:</p><p>â€¢ for ML phase, instead of just using a binary model, different parameters could be used to fill our ğ‘šğ‘œğ‘ ğ‘¡ğ¹ ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘’ğ‘›ğ‘¡ğ‘Šğ‘œğ‘Ÿğ‘‘ğ‘  vector, such as Inverse Document Frequency (IDF), relative frequency or other state of the art metrics;</p><p>â€¢ try to use other machine learning models instead of linear regression, such as Support Vector Machine (SVM) or Neural Networks (NN).</p><p>The study of documents collection is of fundamental importance to construct a good retrieval system: it's difficult to provide universal assumptions regarding them, and they must be treated case by case to get the best results. Although our system recalls a very high percentage of the relevant documents (about 86%, as shown in Section 5), there is still room for improvements regarding this aspect:</p><p>â€¢ develop a more sophisticated analyzer, in particular by using shingles and more advanced techniques of natural language processing;</p><p>â€¢ try different similarity functions;</p><p>â€¢ dynamic query weights assignment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="3,196.54,473.51,202.20,10.91;3,158.59,269.65,278.10,192.60"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of a document in JSON format</figDesc><graphic coords="3,158.59,269.65,278.10,192.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="8,168.30,594.45,258.69,10.91;8,154.58,462.96,286.13,120.23"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Scaling of NDCG@5 measure w.r.t. changes of ğ‘ğ‘™ğ‘â„ğ‘.</figDesc><graphic coords="8,154.58,462.96,286.13,120.23" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="9,89.29,225.39,416.69,10.91;9,130.74,238.06,99.18,9.96;9,184.76,84.19,225.75,129.94"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: All major performance measure for all three approaches: pure BM25 score, pure ML score, and mixed (ğ‘ğ‘™ğ‘â„ğ‘ = 0.6).</figDesc><graphic coords="9,184.76,84.19,225.75,129.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3" coords="9,123.88,466.32,347.51,10.91;9,247.76,365.28,99.75,89.78"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Scaling of NDCG@5 measure w.r.t. the number of words used in ML phase.</figDesc><graphic coords="9,247.76,365.28,99.75,89.78" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="10,206.72,254.75,181.83,10.91;10,99.02,84.19,397.24,159.29"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Recall of all 49 topics of both runs.</figDesc><graphic coords="10,99.02,84.19,397.24,159.29" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5" coords="11,177.00,437.65,241.28,10.91;11,89.29,340.99,436.10,85.40"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Statistical summary of data on average precision.</figDesc><graphic coords="11,89.29,340.99,436.10,85.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6" coords="12,189.47,540.66,216.34,10.91;12,89.29,84.19,498.00,445.20"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: BoxPlot of the 5 runs on average precision.</figDesc><graphic coords="12,89.29,84.19,498.00,445.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7" coords="13,185.19,407.46,224.91,10.91;13,89.29,84.19,498.00,312.00"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: StripChart of the 5 runs on average precision</figDesc><graphic coords="13,89.29,84.19,498.00,312.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8" coords="13,189.76,659.85,215.76,10.91;13,89.29,562.49,431.90,86.10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Statistical summary of data on NDCG@5.</figDesc><graphic coords="13,89.29,562.49,431.90,86.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9" coords="14,202.23,591.01,190.81,10.91;14,89.29,96.15,418.80,483.60"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: BoxPlot of the 5 runs on NDCG@5.</figDesc><graphic coords="14,89.29,96.15,418.80,483.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10" coords="15,197.95,420.06,199.38,10.91;15,89.29,84.19,417.60,324.60"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: StripChart of the 5 runs on NDCG@5</figDesc><graphic coords="15,89.29,84.19,417.60,324.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11" coords="16,189.30,355.01,216.68,10.91;16,89.29,242.04,419.40,101.70"><head>Figure 13</head><label>13</label><figDesc>Figure 13: p-value t-test matrix on average precision</figDesc><graphic coords="16,89.29,242.04,419.40,101.70" type="bitmap" /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>
