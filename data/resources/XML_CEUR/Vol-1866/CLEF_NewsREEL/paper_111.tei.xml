<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,154.76,116.26,306.34,12.45;1,136.16,134.19,343.04,12.45;1,151.01,152.13,313.34,12.45">Recommending News Articles in the CLEF News Recommendation Evaluation Lab with the Data Stream Management System Odysseus</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName coords="1,257.89,189.56,99.57,8.80"><forename type="first">Cornelius</forename><forename type="middle">A</forename><surname>Ludmann</surname></persName>
							<email>cornelius.ludmann@uni-oldenburg.de</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Oldenburg</orgName>
								<address>
									<addrLine>Escherweg 2</addrLine>
									<postCode>26121</postCode>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,154.76,116.26,306.34,12.45;1,136.16,134.19,343.04,12.45;1,151.01,152.13,313.34,12.45">Recommending News Articles in the CLEF News Recommendation Evaluation Lab with the Data Stream Management System Odysseus</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0F7197A5377E8D33FB350A99057DECB7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Recommender Systems, Data Stream Processing 1 https://</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A crucial aspect of recommending news articles is the relevance of currentness of articles. Every day, news portals add plenty of new articles. Typically, users are more interested in recently published articles (or articles that provide background information to recently published articles) than in older ones. That leads to the demand to continuously adapt the set of recommendable items in a recommender system. In this paper, we share our experiences with the usage of the generic and open source Data Stream Management System (DSMS) Odysseus as a Recommender System in the CLEF NewsREEL 2017. We continuously calculate the currently most read articles based on a stream of impression events. Our approach uses operators of a stream-based variant of the relational algebra that respects validity intervals of events. This allows us to continuously calculate the K most popular articles (Top-K set regarding to the number of views) in a sliding time window based on well established relational operations. The flexible composition of operators allows us to variate, e.g., the grouping of impressions to get different recommendation sets for different user groups or the exclusion of articles the user already knows.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A recommender system as a component of modern information systems provides a user with a set of items (e.g., news articles, movies, or products) which might be of interest to him or her. The challenge is to select a small sample from a big collection of items that hopefully meets the taste of the user. A common approach is to learn from previous actions (e.g., page impressions of a web news portal) to estimate the usefulness of items. The K most useful items are presented to the user as recommendations.</p><p>The CLEF News Recommendation Evaluation Lab <ref type="bibr" coords="1,378.05,632.15,10.64,8.80" target="#b3">[4]</ref> (NewsREEL) allows researchers to evaluate recommender systems with real user data in real-time. They provide a platform, called Open Recommendation Platform (ORP), that sends the participants events (impressions and clicks on recommendations) of real commercial news portals. The participants have to analyze the data and must answer requests for recommendations with a set of news articles within a timespan of 100 ms. The recommendations are displayed on the news portal next to the article a user currently reads. For each participant, the organizers measure the clicks on the recommendations and calculates the Click Through Rate (CTR).</p><p>In order to participate, a participant needs to implement a server that processes the events and replies to recommendation requests. The organizers provide a framework 1 that parses the events and lets one implement his/her own algorithms. However, using that framework means you need to take care of the data management and processing of potentially unbounded data streams of events.</p><p>In this paper we present our solution that uses the general purpose Data Stream Management System (DSMS) called Odysseus 2 <ref type="bibr" coords="2,349.77,262.91,10.16,8.80" target="#b0">[1]</ref>. It adapts the concepts of Database Management Systems (DBMS) to process data streams with continuous queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section we give a summary of the ORP platform, the CLEF NewsREEL, and the DSMS Odysseus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">ORP and CLEF NewsREEL</head><p>ORP as the technical platform for NewsREEL provides events of user activity of different news web portals in real-time. Participants are invited to use these events to calculate recommendations. The recommendations have to be returned upon request within 100 ms. ORP selects a set of recommendations at random out of all valid recommendation responses of all participants and displays the recommendations to the users next to the articles. As evaluation criteria, ORP uses click through rate (CTR). It counts how many of the requested recommendations get clicks by the users of the news portals. The fraction of clicks divided by the number of displayed recommendation sets is the CTR.</p><p>Participants have to subscribe the following data streams:</p><p>1. Notifications about user events (e.g., a user reads a news article).</p><p>2. Requests for recommendations, to which the participants have to respond to.</p><p>3. Notifications about new or updated news articles. 4. Error notifications (e.g., a participant response could not be parsed).</p><p>In our approach we use the first two streams: The user events stream provides impressions for news articles in real-time. It comprises the news article ID, publisher ID, user/session ID, user geolocation code, and other information about the impression. That is our source of data to calculate recommendation sets.</p><p>The requests stream triggers the reply of an ordered set of article IDs-the recommendations. A request consists of similar attributes as the impressions: The article the user reads currently, the publisher of the article, the user, etc.</p><p>The events are pushed via HTTP POST request as JSON documents. The response of a request for recommendations has to be the article IDs intended to recommend to the user. For each participant ORP sends the data with an individual data rate. Participants that are able to process more data in time get a higher data rate. ORP determines the individual data rate by increasing it until the participant is not able to answer in time anymore. According to the organizers, each algorithm has to give at least 75 % of the amount of recommendations the baseline approach gave in order to be considered. That should ensure that the algorithms are able to handle the workload and allows the comparison of different approaches.</p><p>Table <ref type="table" coords="3,176.07,274.83,4.88,8.80">1</ref> shows the results of NewsREEL 2017 <ref type="bibr" coords="3,343.13,274.83,10.31,8.80" target="#b5">[6]</ref> as provided by the organizers. It shows the name of the recommender approach, the number of recommendations given, the number of clicks on recommendations, and the click through rate. Additionally, we added the last column that indicates if the approach gave at least 75 % of the baseline recommender (BL2Beat). Each recommender that did not meet this criteria has been grayed out. That applies to each recommender that gave less than 46,539 recommendations. Our approaches have been highlighted in bold face.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">DSMS-The Odysseus System</head><p>The concept of a DSMS bases on the relation algebra of Database Management Systems (DBMS). Instead of managing a static database of relations, a DSMS manages volatile data that is pushed to the system by active sources. That results in a potentially unbounded sequence of elements-the data stream. Similar to a DBMS, a user of a DSMS writes a query by the use of a query language and the system builds a Query Execution Plan (QEP), which consists of reusable operators. Each operator is responsible for a certain operation. Examples of common operators are selection (filtering of elements), projection (filtering of attributes of elements), join (combining of elements of two data streams), and aggregation (combining a set of elements to a single resulting value).</p><p>A relational DSMS extends the concept of a relational DBMS by time-aware and incremental data processing. The underlying concept has been extensively studied, e.g. in <ref type="bibr" coords="4,202.35,512.92,10.51,8.80" target="#b2">[3,</ref><ref type="bibr" coords="4,214.52,512.92,7.75,8.80" target="#b1">2,</ref><ref type="bibr" coords="4,223.93,512.92,7.75,8.80" target="#b4">5,</ref><ref type="bibr" coords="4,233.34,512.92,7.01,8.80" target="#b0">1]</ref>.</p><p>We treat events as tuples with a fixed schema. Each event occurs at a certain point in time t ∈ T with T as set of discrete and ordered time instances, e.g., the UNIX timestamp or an arbitrary application/event time (cf. <ref type="bibr" coords="4,401.43,549.95,10.30,8.80" target="#b4">[5]</ref>).</p><p>The most important differences to a DBMS are that a DSMS holds its data in memory and supports (sliding time) windows. <ref type="foot" coords="4,332.96,573.48,3.97,6.16" target="#foot_0">3</ref> That allows to define a finite set of valid tuples for each point in time t ∈ T , e.g., to calculate a moving average of all elements not older than 60 seconds. The term snapshot reducibility <ref type="bibr" coords="4,440.10,598.94,10.37,8.80" target="#b4">[5]</ref> claims that the resulting tuples of a query of a stream processing system at a specific Listing 1.1: CQL Query Definition point in time t are the same as the resulting tuples of a corresponding query of a DBMS over the set of all valid tuples at t.</p><p>In this paper we use the concept of validity intervals (cf. <ref type="bibr" coords="5,398.22,459.50,10.23,8.80" target="#b4">[5]</ref>). This approach adds an additional operator to the relational algebra-the window operator ω w (R). It assigns validity intervals to elements of a relational stream R. E.g., a sliding time window of size w states that the processing at a point in time t should respect all events not older than t -w. Therefore, the operator sets a (half open) validity interval [t s , t e ) with t s = t and t e = t + w to an event that has been arisen at time t. Thus, the other operators do not need to know the window size: The calculation of a result at time t need to respect all events where t ∈ [t s , t e ) for the certain event. These are all events that are not older than t -w.</p><p>Fig. <ref type="figure" coords="5,170.10,584.33,5.00,8.80" target="#fig_0">1</ref> illustrates the concept of snapshot reducibility with validity intervals. It shows the validity intervals for the elements and a sliding time window of size w = 5. It depicts a part of a data stream from t = 102 to t = 112 with the elements E58 to E65. A sliding time window of size w = 5 defines that at each point in time t all elements that are not older than t -5 should be considered as valid. That means at point t = 109 in Fig. <ref type="figure" coords="5,319.58,644.10,4.90,8.80" target="#fig_0">1</ref> all elements not older than t = 105 are valid. That corresponds to a window from 105 to 109.</p><p>To process the events of a data stream, the user writes one or more queries. In contrast to queries of a DBMS, a query will be executed until the user stops it explicitly. Such a query is called a continuous query since it processes the data continuously. To write a query, the users take advantage of a query language, as the SQL-like stream-based query language CQL <ref type="bibr" coords="6,364.17,166.75,10.73,8.80" target="#b1">[2]</ref> or the functional query language PQL <ref type="bibr" coords="6,200.35,178.71,9.96,8.80" target="#b0">[1]</ref>.</p><p>Similar to a DBMS, the stream processing system translates the query to a Query Execution Plan (QEP; in the streaming context also called data flow graph). A QEP is a directed graph of operators. It determines the order of processing and can be optimized, e.g., by changing the order of operators.</p><p>In addition to the actual stream processing, a DSMS is also responsible for resource and user management, authentication, authorization, accounting, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">General Approach</head><p>To illustrate how to use a DBMS as a RecSys in the CLEF NewsREEL challenge, we present an approach that recommends the most popular articles of the last 30 minutes as basis query for further improvements. Listing 1.1 shows the definition of the query in CQL. This is very similar to SQL and consists of a data definition (DDL) and a data manipulation (DML) part.</p><p>The first part is the definition of the input streams (Lines 2-5) and the output stream (called sink, Line 6). This is similar to a CREATE TABLE statement of a DBMS. It consists of the name of the stream (e.g., events) and a schema definition (truncated in Listing 1.1). The stream or sink definition includes also information about the data connection (e.g., HTTP, TCP) and data format (e.g., CSV, JSON). This is omitted in Listing 1.1 because this is out of the scope of this paper. After parsing the incoming data each event results in a tuple with a fixed schema.</p><p>The second part is the definition of the actual queries. It consists of three parts: the pre-processing of the events (lines 9-13), the counting of the number of impressions for each article (lines 14-17) and the aggregation of the six most popular articles for each publisher (lines 18-24). Each of this is expressed as a view definition, which allows to reference the results in the subsequent queries. The impressions view selects the article ID and publisher ID of all events of type "impression" that have an article ID. Additionally, it defines a sliding time window of a fixed size (e.g., 30 minutes). The result is used in the counted_impressions view. It counts the number of impressions (in the time window) of each unique pair of publisher and article ID. When a new impression arrives or an event gets invalid, the count changes and a new tuple is produced that updates the previous value. The topk_sets view aggregates the counted impressions to a list of articles IDs of the six most popular articles for each publisher.</p><p>The third part uses the list of most popular articles to answer the recommendation requests (lines 27-31). For this, we join a request event with an event of the topk_sets view for the events where publisher ID of request and recommendation set are the same. The stream-based join operator solely joins events that are valid at the same time (which means they have overlapping validity intervals). Because the aggregation of the topk_sets view updates the most popular articles set when they change, all resulting tuples of the same publisher have non-overlapping validity intervals: For each point in time there is exactly one valid aggregation result for the same group. By defining a sliding time window of size 1 (validity of 1 time slice) over the stream of requests, the join assigns exactly one set of article IDs to each request event.</p><p>Recommend. The resulting QEP is depicted in Fig. <ref type="figure" coords="7,317.39,359.60,3.87,8.80" target="#fig_1">2</ref>. It consists of the following types of operators:</p><p>-A window ω w (R) as described in the previous section.</p><p>We use this operator to control how long the impression events are considered by the subsequent aggregation operator ( 1 in Fig. <ref type="figure" coords="7,366.13,413.97,4.34,8.80" target="#fig_1">2</ref>) and to limit the validity of a recommendation request to 1 time slice ( 2 ) in order to join it with exactly one set of recommendations. -A selection σ ϕ (R) removes all tuples t ∈ R for which the propositional expression ϕ does not hold.</p><p>We use the selection to filter the impressions from the event stream ( 3 ). -A projection π a1,...,an (R) restricts the set of attributes of each tuple t ∈ R to the attributes {a 1 , . . . , a n }. An extended version, called map, allows to use functions (e.g., π f (a1),a2,f (a3,a4),...,an (R)) that are invoked with one ore more attributes.</p><p>The projection is used in our example to filter the needed attributes of the impression events and of the recommendation responses ( 4 and 8 ). -An aggregation γ G,F (R) takes a set of tuples t ∈ R and returns for each group defined by the grouping attribute g ∈ G a single tuple as result that contains the results of the aggregate functions f ∈ F . Typical aggregate functions are sum, count, avg, max, and min. The stream-based variant continuously aggregates tuples that lie in the same window (which means they have overlapping validity intervals).</p><p>We use the aggregation to count the number of impressions of each article ( <ref type="formula" coords="7,151.04,657.11,3.99,7.08">5</ref>) and to nest the 6 most viewed articles into one outgoing tuple ( 6 ). -A join R θ S combines the tuples of R and S for which a condition θ holds.</p><p>The stream-based variant claims also that the tuples have overlapping time intervals. The validity interval of a resulting tuple is the intersection of the validity intervals of the input tuples.</p><p>The join ( 7 ) is responsible for the matching of the requests to the recommendation sets.</p><p>The important parts of the query are the calculating of a ranking score (aggregation 5 ), the building of the recommendation sets (aggregation 6 ), and the matching of requests and recommendation sets (join 7 ). These operators are heavily influenced by validity intervals of the events, that are assigned by the window operator.</p><p>The calculation of the recommendation sets is implemented by two aggregation operators: One to calculate the popularity of an article and one to combine the most popular articles to a recommendation set. Our aggregation operator is data driven. That means it outputs an updated result for every incoming event.</p><p>The operator internally holds a state s for each group and updates this state using an aggregation function add(s, e) → s for each incoming event e. For the count function in Listing 1.1 the aggregation function is defined as: add(s, e) = s + 1.</p><p>Since the aggregation is defined over a sliding time window the operator has to remove all values that do not lie in the window anymore. For that, all events whose end timestamp of their validity intervals are lower or equal than the start timestamp of the incoming event have to be removed. This is done before adding a new event by using a function remove(s, e) → s, e.g., for count: remove(s, e) = s -1.</p><p>After each change of the state the operator outputs a result by calling the function eval(s) → e, which calculates the resulting event based on the state. For count, it just outputs the state value s. Other functions as for example avg need to calculate the resulting value. Consider a state for avg that consists of a count and a sum, the eval function is eval(s) = s.sum s.count . Listing 1.2 illustrates the algorithm of the aggregation operator.</p><p>The second aggregation operator uses the nest function with add(s, e) = s. insertSorted(e) (sorted by count), remove(s, e) = s. remove(e), and eval(s) = s. sublist(0, 6). The output is an ordered set of the article IDs of the 6 events on the top.</p><p>Since the recommendation sets are calculated incrementally and continuously, the calculation of the response to a request is the executing of the join operator. This leads to very short latencies. The join holds for each group (here the publisher ID) the latest known recommendation set in a hash map. The operator appends the matching recommendation sets to each request and gives the result to the sink that transfers it back to the inquirer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Variations</head><p>During the CLEF NewsREEL 2017, we evaluated six different approaches that are based on the general approach presented in the previous section. Table <ref type="table" coords="9,475.76,272.28,5.08,8.80" target="#tab_3">2</ref> shows an overview over our approaches and their resulting CTRs.</p><p>The approach ody0 uses the aggregation function nest over a sliding time window of 60 min. to aggregate a set of unique item IDs that have been read in the past 60 min. After that, a map function is used to randomly draw 6 items to recommend them. This approach acts as our internal baseline.</p><p>All other approaches follow the same pattern. Given a data stream of article IDs and optional further attributes:</p><p>1. Define a sliding time window of size w over the data stream. (In our DSMS, this is done by annotating validity intervals.) 2. Partition the data by the article IDs and optional other attributes p 1 , p 2 , . . . , p n . 3. Apply an aggregation function over each partition that calculates a score for each item in each partition (over the sliding time window). (In our approach we used the count function. In case of explicit item rating, the average function would be an alternative.) 4. Optional: Combine the results of different approaches to prevent underfull recommendation sets.</p><p>This results in a incrementally and data-driven calculated stream of recommendation sets for each partition.</p><p>The approaches ody1 and ody2 partition the data by publisher IDs as described in the previous section. They differ solely in the window size. ody1 considers all impressions of the past 30 min., ody2 of the past 5 min. The evaluation shows, that the 5 min. window leads to a higher CTR than the 30 min. window.</p><p>ody3 uses the same window size as ody2 but adds as partition attribute the user location. Because more partitions lead to less data in each partition, our tests show that a larger window size than 5 min. is necessary to have enough data in each partition and each window. This approach reaches a similar CTR than ody2.</p><p>In contrast, ody4 and ody5 calculate the recommendations by aggregating the previously successfully given recommendations of the past 12 hours. This information is part of the user events stream. For each news article i we calculated the set of news articles that have been successfully recommended to visitors of item i the most. Additionally, ody5 fills the recommendation set up with recommendations of ody1 in case that there are less than six successfully recommended items in the past 12 hours. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation of the Window Size</head><p>A crucial parameter is the window size of the impression events. Since we want to count the current views of each article we have to figure out which time span leads to a set of impression events that represent the current popularity of articles: Is the size too large the system is not sensitive to popularity changes (concept drifts). Is it too small there is not enough data to distinguish the popularity of articles.</p><p>To determine an appropriate window size we conducted an experiment. We ran 21 queries as shown in Listing 1.1 with different window sizes in parallel over the same stream (1 to 10 min, 20 min, 30 min, 40 min, 50 min, 60 min, 90 min, 2 hrs, 3 hrs, 6 hrs, 12 hrs, 24 hrs). Similar to the Interleaved Test-Then-Train (ITTT) evaluation method we calculated the reciprocal rank of each article of an impression event before it has influenced the recommendation set. That gave us a mean reciprocal rank (MRR) for each query resp. window size. A higher MRR means there are frequently viewed articles more often near the top. Additionally, we calculated how often an article is part of the top 6 of the most popular items in the different time windows (Precision@6).</p><p>Because the data rates of the publishers are different (some publishers have many more impressions than others) we evaluated the window sizes for each publisher separately. Window Size Percent of recomm. sets w/ less than 6 articles (c) Percent of Underfull Recomm. Sets Fig. <ref type="figure" coords="11,153.37,454.50,3.86,8.80">3</ref>: Mean Reciprocal Rank, Precision@6, and underfull recommendation sets for window sizes 1 -10 min and publisher with ID 35774. Fig. <ref type="figure" coords="11,170.53,520.60,5.08,8.80">3</ref> shows the result for the publisher with ID 35774 (window sizes 1 to 10 min). As you can see in Fig. <ref type="figure" coords="11,269.55,532.56,8.32,8.80">3a</ref>, a window of 2 min. leads to the highest MRR of 0.44804. Correspondingly, the Precision@6 in Fig. <ref type="figure" coords="11,368.97,544.51,10.65,8.80">3b</ref> shows that about 59% of each impression the user views an article that is part of the 6 most popular articles of the last 2 min. For this publisher, lower or higher window sizes lead to lower values.</p><p>Besides the metrics MRR and Precision@6, we measured how often a window does not have impressions of at least 6 distinct articles so that the recommendation sets have less than 6 recommendations (underfull recommendation sets). Fig. <ref type="figure" coords="11,471.28,620.19,9.32,8.80">3c</ref> shows the fraction of underfull recommendation sets. As expected, the fraction of underfull recommendation sets decreases with higher window sizes. Overall, the fraction of underfull recommendation sets for publisher 35774 is pretty low.</p><p>Even a window size of 2 min. has just 0.023% recommendation sets with less than 6 recommendations.</p><p>The results of the other publisher follow this pattern, even though publisher with lower data rates get better results with bigger window sizes. As a tradeoff between different publishers we made good experiences with a window size of five minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this paper we presented an approach for the CLEF NewsREEL 2017. We implemented a RecSys by using a generic Data Stream Management System. By analyzing impression events of users we calculated a set of recommendations based on the popularity in a given time window. To find an appropriate time window we evaluated different sizes in parallel.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="4,244.83,294.01,125.70,8.80"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Snapshot Reducibility</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="7,244.22,312.21,126.91,8.80"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Query Execution Plan</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="3,170.44,390.08,274.47,238.31"><head>Recommender # Recomm. # Clicks CTR 75 % BL</head><label></label><figDesc></figDesc><table coords="3,170.44,401.40,274.47,226.99"><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Time of</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>w = 5</cell><cell cols="3">Observation</cell><cell></cell></row><row><cell cols="4">Out-dated Elements</cell><cell></cell><cell></cell><cell>Window</cell><cell></cell><cell></cell><cell cols="3">Prospective Elements</cell></row><row><cell>. . .</cell><cell cols="2">E58</cell><cell cols="3">E59 E60 E61 E62</cell><cell></cell><cell></cell><cell>E63</cell><cell>E64</cell><cell>E65</cell><cell>. . .</cell></row><row><cell>Validity Intervals</cell><cell>E58</cell><cell cols="5">E59 Overlapping Intervals at t = 109 E60 E61 E62</cell><cell></cell><cell>E63</cell><cell>E64</cell><cell>E65</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Application Time t</cell></row><row><cell>102</cell><cell cols="2">103</cell><cell>104</cell><cell>105</cell><cell>106</cell><cell>107</cell><cell>108</cell><cell>109</cell><cell>110</cell><cell>111</cell><cell>112</cell></row><row><cell></cell><cell cols="3">Riadi NV 01</cell><cell></cell><cell></cell><cell>443</cell><cell></cell><cell cols="2">12 0.0271</cell><cell>no</cell></row><row><cell></cell><cell cols="3">ORLY KS</cell><cell></cell><cell></cell><cell>42,786</cell><cell></cell><cell cols="2">896 0.0209</cell><cell>no</cell></row><row><cell></cell><cell cols="2">1. ody4</cell><cell></cell><cell></cell><cell></cell><cell>72,601</cell><cell></cell><cell cols="2">1,139 0.0157</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">IRS5</cell><cell></cell><cell></cell><cell></cell><cell>3,708</cell><cell></cell><cell cols="2">58 0.0156</cell><cell>no</cell></row><row><cell></cell><cell cols="2">2. ody5</cell><cell></cell><cell></cell><cell></cell><cell>81,245</cell><cell></cell><cell cols="2">1,268 0.0156</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">3. ody3</cell><cell></cell><cell></cell><cell></cell><cell>59,227</cell><cell></cell><cell cols="2">813 0.0137</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">4. ody2</cell><cell></cell><cell></cell><cell></cell><cell>63,950</cell><cell></cell><cell cols="2">875 0.0137</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">5. IT5</cell><cell></cell><cell></cell><cell></cell><cell>68,582</cell><cell></cell><cell cols="2">925 0.0135</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">6. eins</cell><cell></cell><cell></cell><cell></cell><cell>61,524</cell><cell></cell><cell cols="2">817 0.0133</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">7. yl-2</cell><cell></cell><cell></cell><cell></cell><cell>60,814</cell><cell></cell><cell cols="2">747 0.0123</cell><cell>yes</cell></row><row><cell></cell><cell cols="3">8. WIRG</cell><cell></cell><cell></cell><cell>49,830</cell><cell></cell><cell cols="2">600 0.0120</cell><cell>yes</cell></row><row><cell></cell><cell cols="2">9. ody1</cell><cell></cell><cell></cell><cell></cell><cell>68,768</cell><cell></cell><cell cols="2">810 0.0118</cell><cell>yes</cell></row><row><cell></cell><cell cols="3">10. BL2Beat</cell><cell></cell><cell></cell><cell>62,052</cell><cell></cell><cell cols="2">726 0.0117</cell><cell>yes</cell></row><row><cell></cell><cell cols="3">11. RIADI pn</cell><cell></cell><cell></cell><cell>77,723</cell><cell></cell><cell cols="2">879 0.0113</cell><cell>yes</cell></row><row><cell></cell><cell>12. IL</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>79,120</cell><cell></cell><cell cols="2">813 0,0103</cell><cell>yes</cell></row><row><cell></cell><cell cols="3">13. RIADI nehyb</cell><cell></cell><cell></cell><cell>75,535</cell><cell></cell><cell cols="2">764 0.0101</cell><cell>yes</cell></row><row><cell></cell><cell cols="3">Has logs</cell><cell></cell><cell></cell><cell>816</cell><cell></cell><cell cols="2">6 0.0074</cell><cell>no</cell></row><row><cell></cell><cell cols="2">ody0</cell><cell></cell><cell></cell><cell></cell><cell>23,023</cell><cell></cell><cell cols="2">166 0.0072</cell><cell>no</cell></row><row><cell></cell><cell cols="3">RIADI hyb</cell><cell></cell><cell></cell><cell>349</cell><cell></cell><cell cols="2">2 0.0057</cell><cell>no</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="7">Table 1: Results of CLEF NewsREEL 2017</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" coords="10,136.16,182.32,343.04,197.15"><head>Table 2 :</head><label>2</label><figDesc>Overview over our approaches in the CLEF NewsREEL 2017</figDesc><table coords="10,175.80,182.32,38.93,7.92"><row><cell>Approach</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0" coords="4,144.73,634.83,336.05,7.92;4,144.73,645.79,335.86,7.92;4,144.73,656.75,57.49,7.92"><p>In this paper we limit ourselves to sliding time windows. However, there are also other types of windows, e.g., element windows, tumbling windows etc. that are supported by our DSMS.</p></note>
		</body>
		<back>

			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>github.com/plista/orp-sdk-java 2</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct coords="12,138.35,337.80,343.53,7.92;12,146.57,348.76,334.26,7.92;12,146.91,359.72,197.39,7.92" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="12,442.04,337.80,39.83,7.92;12,146.57,348.76,334.26,7.92;12,146.91,359.72,29.48,7.92">Odysseus: A highly customizable framework for creating efficient event stream management systems</title>
		<author>
			<persName coords=""><forename type="first">H</forename><forename type="middle">J</forename><surname>Appelrath</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Geesen</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Grawunder</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Michelsen</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Nicklas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,197.75,359.72,34.38,7.92">DEBS&apos;12</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="367" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,370.68,342.24,7.92;12,146.91,381.64,287.57,7.92" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="12,285.14,370.68,195.45,7.92;12,146.91,381.64,130.15,7.92">The CQL continuous query language: semantic foundations and query execution</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Arasu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,284.20,381.64,59.66,7.92">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="142" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,392.60,342.24,7.92;12,146.91,403.56,245.20,7.92" xml:id="b2">
	<analytic>
		<title level="a" type="main" coord="12,395.84,392.60,84.75,7.92;12,146.91,403.56,80.75,7.92">Models and issues in data stream systems</title>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Babcock</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,249.02,403.56,45.47,7.92">PODS 2002</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,414.51,343.52,7.92;12,146.91,425.47,334.96,7.92;12,146.57,436.43,222.01,7.92" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="12,207.04,425.47,257.36,7.92">Benchmarking news recommendations: The clef newsreel use case</title>
		<author>
			<persName coords=""><forename type="first">F</forename><surname>Hopfgartner</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Brodt</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Seiler</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Kille</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Lommatzsch</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Turrin</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Serény</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,146.57,436.43,77.70,7.92">ACM SIGIR Forum</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="129" to="136" />
			<date type="published" when="2016">2016</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,447.39,342.58,7.92;12,146.91,458.35,236.88,7.92" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="12,240.92,447.39,240.00,7.92;12,146.91,458.35,101.01,7.92">Semantics and implementation of continuous sliding window queries over data streams</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Krämer</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="12,255.17,458.35,51.80,7.92">ACM TODS&apos;</title>
		<imprint>
			<biblScope unit="volume">09</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="12,138.35,466.99,343.53,10.23;12,148.19,477.95,332.40,10.23;12,146.91,491.23,219.57,7.92" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="12,162.36,480.27,318.23,7.92;12,146.91,491.23,55.24,7.92">Clef 2017 newsreel overview: A stream-based recommender task for evaluation and education</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Lommatzsch</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Kille</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">F</forename><surname>Hopfgartner</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Brodt</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Seiler</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Ö</forename><surname>Özgöbek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="12,223.46,491.23,44.56,7.92">CLEF 2017</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
