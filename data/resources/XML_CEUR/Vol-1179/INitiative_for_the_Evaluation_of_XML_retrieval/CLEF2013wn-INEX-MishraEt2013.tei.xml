<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,155.84,115.90,303.68,12.90;1,231.95,133.83,151.47,12.90">SPAR-Key: Processing SPARQL-Fulltext Queries to Solve Jeopardy! Clues</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,190.13,171.88,60.39,8.64"><forename type="first">Arunav</forename><surname>Mishra</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max Planck Institute for Informatics</orgName>
								<address>
									<addrLine>Campus E1.4</addrLine>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,259.97,171.88,67.23,8.64"><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max Planck Institute for Informatics</orgName>
								<address>
									<addrLine>Campus E1.4</addrLine>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,353.52,171.88,67.24,8.64"><forename type="first">Martin</forename><surname>Theobald</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Antwerp</orgName>
								<address>
									<addrLine>Middelheimlaan 1</addrLine>
									<postCode>2020</postCode>
									<settlement>Antwerp</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,155.84,115.90,303.68,12.90;1,231.95,133.83,151.47,12.90">SPAR-Key: Processing SPARQL-Fulltext Queries to Solve Jeopardy! Clues</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8A3485A04FB325881E6952E1C6EE1E46</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-06-26T15:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Entity IDX (Entity ID</term>
					<term>Term</term>
					<term>Score) Keywords Term IDX (Term</term>
					<term>Entity ID</term>
					<term>Score) Table 6. Indexes built over the Keywords table</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe our SPAR-Key query engine that implements indexing, ranking, and query processing techniques to run a new kind of SPARQL-fulltext queries that were provided in the context of the INEX 2013 Jeopardy Task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The LOD track of INEX 2012 introduced the new Wikipedia-LODv1.1 collection that combined highly structured semantic data and unstructured (or semi-structured) textual data with the goal of improving IR-tasks (adhoch search task and faceted search task) and Question-Answering tasks (Jeopardy task). The entity-centric collection comprised XML-ified documents, coined Wiki-XML documents, as the basic unit of data, where each documents corresponded to a Wikipedia entity, and combined semantic (RDF) data from DBpedia and YAGO2 Knowledge Bases, and textual data from the Wikipedia article that describe the entity. The Jeopardy task, defined on the Wikipedia-LODv1.1 collection as a part of the LOD track, evaluated retrieval techniques over a unique query benchmark of 90 queries, given in the new SPARQL-FT format. The SPARQL-FT queries of the benchmark represented a translation of Jeopardy-style Natural Language (NL) questions into a combination of W3C standard SPARQL and traditional keyword queries <ref type="bibr" coords="1,166.88,451.63,10.58,8.64" target="#b6">[7]</ref>. In INEX 2013, the same efforts have been continued for the LOD track, however, with a new and more complete version of the collection, Wikipedia-LODv2.0, and a larger query benchmark for the Jeopardy task with 105 queries.</p><p>In this paper, we introduce a query engine, called SPAR-Key, which we developed in the context of our participation in the Jeopardy Task of the INEX 2013 Linked Data Track. This work has been a continuation of our attempts in the INEX 2012 Jeopardy task <ref type="bibr" coords="1,153.88,523.36,10.58,8.64" target="#b0">[1]</ref>. At a high level, the SPAR-Key engine translates a SPARQL-FT query into a conjunctive SQL query and processes it over a relational database schema. We delineate three SPARQL-FT-to-SQL translators as a part of the SPAR-Key engine, namely SPAR-Key Supremacy, SPAR-Key Ultimatum-No Phrases, and SPAR-Key Ultimatum-Phrases, and submit runs based on each variant. In addition, we motivate and analyze the translation strategies, and investigate the improvements in the quality of results against the official evaluations released by the INEX community.</p><p>2 Data Storage in Relational-DBMS Data management and storage becomes a critical in designing a query processor. Thinking of scalable data storage, the most common option is a Relational Data Management</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="12" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="13" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>System (relational-DBMS). Though we also explored other approaches like file systems, graph-databases, etc., a relational-DBMS based approach seemed to be a viable option due to the ease of implementation and re-use of the optimization techniques generally adopted by the database community. Designing a respective database schema as our storage model suffices our need, as we aim to investigate the effectiveness and not maximize the efficiency of the query processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Storage Model for Structured Data</head><p>The RDF data can be commonly perceived as a collection of triples of the form Subject (S), Predicate (P) and Object (O) or, Entity, Property and Value (in entity-relationship terminology). In the last decade, there have been many perspectives put forward by different research communities to manage RDF data. We identify the three most important in order to find the best suited data storage model for our collection, namely a relational perspective, an entity perspective and a graph-based perspective <ref type="bibr" coords="2,420.00,408.50,10.58,8.64" target="#b3">[4]</ref>, and finally, we adopt the relational perspective for our system.</p><p>Storing RDF Data as a Single Relational Table . The vertical representation under the relational perspective enables us to view RDF data as a large collection of triples containing SPO components. By assuming such a serialization of RDF data into a flat relational table, simply means that a given structured query in SPARQL has to be translated into a SQL query and issued to the relational-DBMS.</p><p>As our storage back-end, we use the Oracle 11g relational-DBMS to store the RDF data that we imported from the data dumps of DBpedia and YAGO2. Table <ref type="table" coords="2,434.04,521.77,4.98,8.64" target="#tab_0">1</ref> shows the schema of the table that stores the entire structured part of the collection. We call this table DBpediaCore table and from here on, we refer to the table with this name.</p><p>Creation of the DBpediaCore Table . To parse the structured part of the collection constituting RDF facts, we make use of current Linked Open Data dumps for DBpedia (v3.8) and YAGO2, which are available from the following URLs:</p><p>-DBpedia v3. The N-Triple (.nt) format of the dumps are downloaded and are bulk-loaded into the Jena RDF engine. We make use of the Apache Jena TDB to bulk load the triples into the engine. Jena TDB build its own indexes over the data that can be used to efficiently process SPARQL queries over an RDF store. However, we use the JAVA interface provided by the Jena TDB to traverse over all the triples and further bulk load them into a relational table. Usage of Apache Jena TDB is not strictly necessary for building the triple store in the relational-DBMS as any standard RDF parser could do the job. Our use of Jena was solely to exploit its fast bulk loading mechanism. Table <ref type="table" coords="3,424.52,299.96,4.98,8.64" target="#tab_1">2</ref> shows some statistics of the DBpediaCore table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Storage Model for Unstructured Data</head><p>Traditionally, inverted indices are used as core data structures in keyword-based retrieval systems. Abstractly, these inverted indices facilitate efficient fulltext searches and retrieval of most relevant or best matched documents to a given keyword query. Essentially, inverted indices map every term (as keys) in the corpus to a set of documents with a similarity score that is generated by a scoring function. We use a similar approach however by first generating and later translating such an inverted index into a relational table.</p><p>Storing Textual Data in a Single Relational Table . Commonly keyword-based retrieval systems at least store a map or inverted index mapping every term to the documents in the corpus. This can be viewed as relational data and can be stored in relational-DBMS. Realizing this, we create a relational table called Keywords table to store all the term-entity pairs extracted from the Wikipedia fulltext collection. From here on we refer to the table with this name. The schema of this table is shown in Table <ref type="table" coords="3,438.37,520.00,3.74,8.64" target="#tab_2">3</ref>.</p><p>The Entity ID column essentially stores the Uniform Resource Identifier (URI) of the DBpedia entities. Since in our entity-centric collection, every document corresponds to a DBpedia entity, we prefer to use the prefixes defined by DBpedia to represent these entities, for example htttp://dbpedia.org/resource/entity. Every tuple of the Keywords table represents a term mapped to DBpedia entity and a similarity score to the entity's Wikipedia page.</p><p>Creation of the Keywords Table . We employee a regular SAX parser to parse the XML articles whose general XML structure is still based on that of the original articles. That is, these articles contain a meta-data header with information about the ID, authors, creation date and others, usually also an infobox with additional semi-structured Many approaches motivate to build multiple indexes for different permutations and combinations of the triple components. For example RDF-3x <ref type="bibr" coords="4,390.13,398.22,11.62,8.64" target="#b5">[6]</ref> creates 15 indexes over a triple store. However, we observe that we already achieve decent efficiency with three non-unique, visible and composite indexes on DBpediaCore table as shown in Table <ref type="table" coords="4,170.45,434.09,3.74,8.64" target="#tab_4">5</ref>. Similarly we create two non-unique, visible and composite indexes on the Keywords table. The two indexes are built with the consideration that queries are issued with conditions on the Entity ID column and Term column while the Score column is used for purposes of ranking. Table <ref type="table" coords="4,321.36,469.95,4.98,8.64">6</ref> describes these two indexes built over the Keywords table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Keyword Ranking: Okapi BM25</head><p>In this section, we present the scoring model used to generate the per term-entity scores stored in the third column of the Keywords table. There many well studied state-of-art scoring functions that work well for a definite setting and it would be difficult to claim a generic ranking function that is optimal. For our data, we select a variant of the Okapi BM25 <ref type="bibr" coords="4,162.71,579.17,11.62,8.64" target="#b1">[2]</ref> scoring function with parameters k=1.2 and b=2.0, which works well for the fulltext searches involved in our query processing. The exact BM25 variant we used for ranking an entity e by a string of keywords S in an FTContains operator is given by the following formula:</p><p>score(e, FTContains(e, S))</p><formula xml:id="formula_0" coords="5,184.91,174.32,283.95,65.13">= ti∈S (k 1 + 1) tf (e, t i ) K + tf (e, t i ) • log N -df (t i ) + 0.5 df (t i ) + 0.5 with K = k 1 (1 -b) + b len(e) avg{len(e ) | e in collection}</formula><p>where, 1) N is the number of XML articles in Wikipedia LOD collection.</p><p>2) tf (e, t) is the term frequency of term t in the Wikipedia LOD article associated with entity e. 3) df (t) is the document frequency of term t in the Wikipedia LOD collection. 4) len(e) is the length (sum of tf values) of the Wikipedia LOD article associated with entity e.</p><p>We used the values of k 1 = 2.0 and b = 0.75 as the BM25-specific tuning parameters (see also <ref type="bibr" coords="5,188.71,366.19,11.62,8.64" target="#b1">[2]</ref> for tuning BM25 on earlier INEX settings).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Entity Ranking</head><p>We realize that ranking entities in context of a given structured query becomes a difficult challenge. As a simple approach, we consider it to be reasonable to carry over the aggregated scores of the entities obtained from fulltext searches that are performed for associated fulltext constraints on the entity. However, there may arise a special case where in a SPARQL-FT query, entities do not have fulltext constraints. In such a case all the entities that satisfy the semantic structure defined by the query triple (or triples) pattern, become candidates to either become the final answer, or for further processing. In such cases, we give a default score of 1 to these entities. A more elaborate discussion is presented in <ref type="bibr" coords="5,194.81,514.30,10.58,8.64" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SPAR-Key Supremacy</head><p>In this section, we introduce the first variant of our query engine, called SPAR-Key Supremacy. In addition to the basic ranking methodology discussed in the last section, this system implements a SPARQL-FT-to-SQL translator that: 1) uses SQL Joins over simple "AND conditions" in conjunctive query processing, 2) materializes temporary tables and sub queries to represent intermediate results to improve efficiency, 3) uses a simple selectivity estimation technique to decide join order of temporary tables, and 4) includes additional query optimizations to force the optimizer to follow the decided join order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Materializing Temporary Tables</head><p>One big conjunctive query forces the Oracle optimizer to choose from a very large number of possible query execution plans, and it often chooses an inefficient plan. Thus, to prevent the optimizer from taking such inappropriate decisions, we materialize temporary tables by separately joining the Keywords table instances and the DBpediaCore table instances. This strategy acts as a strong hint for the optimizer. The optimizer selects better query plans for the smaller intermediate queries and store their results into temporary tables which are later joined together to retrieve the final result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluating the Join Order and Forcing Orders via Optimizer Hints</head><p>There are some simple techniques by which we can determine the join order of the tables. One such technique is to maintain an Inverse Document Frequency (IDF) index containing the most frequent terms that occur in the collection. This index follows a very simple layout of a key-value pair, where a key is a term and the value is it's IDF. A frequent term will have lower IDF and hence a select query on the Keywords table, with the term as constraint, will return a larger result set. At the same time, if a term is absent in the feature index, it can be assumed to be infrequent. Every instance of the Keywords table can now be joined in increasing order of the IDF values of their respective terms, thus ensuring the smaller tables to be joined first.</p><p>In our case, since we use the Oracle relational-DBMS as our back-end, it provides a functionality by which the joining of intermediate results can be enforced on the Oracle optimizer. This is achieved by adding optimizer hints to the queries. Of the made available hints by Oracle to guide the query optimizer, we identify that the Ordered hint could force the joining of tables in the determined order while preserving the logics of the join condition in the original query. Thus our query translator automatically adds this hint in the translated SQL queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">SPAR-Key Supremacy: The Rewriting Algorithm</head><p>We can now develop an overall rewriting algorithm by putting together all the afore mentioned steps.</p><p>1. Load the features index containing frequent terms and their IDF values into main memory. 2. Tokenize and stem the FTContains fulltext conditions and decide the order of joins among the keywords from the Features index. 3. Create temporary Keys i tables for each fulltext condition: these contain the results of the OUTER joins over the Keywords table constrained by the terms. 4. Create temporary T ab i tables for each triplet pattern. These contain the results of the INNER joins over the DBpediaCore table which are additionally joined with Keys i temporary tables for each FTContains fulltext condition in the query. 5. Assign a default score of 1 to all triples without any fulltext condition.</p><p>6. Formulate the main select query that combines the T ab i temporary tables via an INNER joins; the join logic is based on the joins given in the original SPARQL query. 7. Finally, drop the temporary tables Keys i and T ab i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SPAR-Key Ultimatum</head><p>In this section we introduce the second and third variant of the query engine, called the SPAR-Key Ultimatum No Phrases and the SPAR-Key Ultimatum Phrases. In fact, these are implementation-wise the same with only one additional component called Phrase Search (discussed in later in Section 4.4) activated in the latter. Thus we describe them together in this section.</p><p>In addition to the basic ranking and efficiency improvement methodologies discussed so far, this system implements a SPARQL-FT-to-SQL translator that: 1) uses Class Selection to prune out false positives, 2) exploits the structure of a give query to identify additional constraints, 3) incorporates URI Search as a basic entity disambiguation tool, and 4) extracts noun phrases and performs proximity search to improve ranking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Class Selection</head><p>We note that additional contextual information can be used to prune out irrelevant entities before performing intermediate INNER joins or OUTER joins, to create temporary Tab or Keys tables (described in the 3.3). For example, entity &lt;Aircraft&gt; has a type &lt;MeansOfTransportation&gt;. It is not hard to see that context or type of an entity can be derived from the DBpedia class to which it belongs. Due to neat hierarchy of classes defined in DBpedia, we can safely obtain the classification of entities. Using this knowledge we can logically partition the RDF data graph based on the classes so as to reduce the search space in the intermediate steps. Figure <ref type="figure" coords="7,374.24,476.54,4.98,8.64">1</ref> shows a snap-shot of the class structure defined in DBpedia found at http://mappings.dbpedia.org. We are only concerned with the DBpedia and YAGO2 classes identified by prefix: &lt;http://dbpedia.org/ontology/class&gt; and &lt;http://dbpedia.org/ontology/yagoclasses/class&gt;.</p><p>The property definition in a class specifies a signature. To understand this, let us consider an example shown in Figure <ref type="figure" coords="7,293.43,548.84,3.74,8.64">2</ref>. This example shows the properties defined in the &lt;Aircraft&gt; class with their signature. In the above example, one can see a property &lt;aircraftUser&gt; defined with a Domain, &lt;Aircraft&gt; and Range &lt;Organization&gt; which are DBpedia classes. Thus if this property should occur as a Predicate in a triple pattern then all the entities classified as &lt;Aircraft&gt; should occur as the Subject of the triple and all the entities classified as &lt;Organization&gt; should occur as the Object of the triple. This forms an important observation to derive the classes of the entities that can occur in a triple pattern of a given query. We can therefore reduce the search space only to those entities that belong to the marked classes. To implement this, we create two indexes that store the Predicates along with their Domains and Ranges separately. The first index is called the PredicateDomainIDX and the second index is called the PredicateRangeIDX. Table <ref type="table" coords="8,398.90,334.80,4.98,8.64">7</ref> depicts the schema of these indexes. These indexes facilitate the class markings of the Subjects and Objects on-the-fly while processing a query. These indexes prove not to be very large in size and can hence easily be loaded into the main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Exploiting the Query Structure</head><p>Interpreting a structured query as a basic graph pattern, leads us to observe two common kinds of query patterns. They are commonly known as a Chain pattern query and a Star pattern query <ref type="bibr" coords="8,191.21,442.81,10.58,8.64" target="#b5">[6]</ref>.</p><p>-Chain pattern is where the Object of the first triple pattern is the Subject of the next triple pattern, again with given Predicates. Figure <ref type="figure" coords="8,352.77,475.51,4.98,8.64">3</ref> shows a generic illustration of a chain pattern. -Star pattern is where multiple triple patterns with different Predicates share the same Subject. These are used to select specific subjects. Figure <ref type="figure" coords="8,408.55,511.18,4.98,8.64">4</ref> shows a generic illustration of a star pattern.</p><p>The query pattern can be used to derive classes of entities even though in a triple pattern a Predicate is not specified by a literal. To see this let us consider an example query as shown in Figure <ref type="figure" coords="8,257.48,567.98,3.74,8.64">4</ref>. By analyzing the Predicate of the first triple pattern (&lt;museum&gt; &lt;located&gt; ?a.), i.e., &lt;located&gt;, we can mark the Object (?a) Index Name Attributes PredicateDomainIDX (Predicate, Domain) PredicateRangeIDX (Predicate, Range) Table <ref type="table" coords="8,167.86,645.37,3.36,8.06">7</ref>. Schema of the PredicateDomainIDX and PredicateRangeIDX indexes Index Name Attributes URI IDX (Entity ID, Term) Table <ref type="table" coords="9,269.01,139.94,3.36,8.06">8</ref>. Schema of the URI index of to be class &lt;City&gt; which is specified by the Range of the Predicate signature ; and then by analyzing the second Predicate &lt;partOf&gt;, we can mark the Subject (?c) of the second triple pattern (?b &lt;partOf&gt; ?a.) to be of class &lt;Country&gt;. Similar analogies can be drawn for chain query patterns also.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Search on the URI Index</head><p>Document titles are considered as an important feature by IR systems among other features like content, context, etc. These document titles tend to summarize the major context of the articles. Following this notion, we also find that most of the entity descriptions or key-concepts in a fulltext condition map to the surface forms of the entity. In our collection these surface forms tend to occur as document titles. Following this idea, we create an additional URI index other than the above described Keywords indexes that mainly stores the surface forms of the articles. For a fulltext condition, SPAR-Key Ultimatum performs an additional look-up on the URI index and then performs an OUTER join with the results of a fulltext search on the article content. By doing this, we include the entities that are missed by a fulltext search on the content. Also the scores of the entities that are found by both the searches are boosted. Table <ref type="table" coords="9,475.61,389.00,4.98,8.64">8</ref> shows the schema of the URI index used by SPAR-Key Ultimatum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Phrase Search</head><p>We observe that the in most of the Jeopardy-style NL questions, the occurrence of the clues are in form of phrases, for example "King of Pop", "Don't be Evil", etc. In addition, we also observe that other clues that mostly describe an entity (in the associated fulltext conditions), contain nouns that most likely to occur in close proximity in the textual data corresponding to the entities, for example, "Christian church founder", "video sharing", etc. Thus we identify these noun phrases as additional features to improve the ranking of the entities. The main idea is to perform a basic Natural Language Processing on the Jeopardy-style questions to extract all the noun phrases and then boost the scores of the entities that contain these noun phrases. To perform the noun phrase extraction, the SPAR-Key Ultimatum uses the Stanford NLP Core <ref type="bibr" coords="10,451.23,131.27,11.62,8.64" target="#b2">[3]</ref> as a black box and then automatically formulates a proximity keyword query by setting the slope between the keywords as the average length of a sentence in Wikipedia. It then performs an OUTER join of the results from the proximity search to the the results of the fulltext search (by assuming independence between keywords), boosting the scores of the entities that are returned by both.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">SPAR-Key Ultimatum:</head><p>The Rewriting Algorithm </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluations</head><p>In this section we provide experimental evaluation of our SPAR-Key query processor over the Wikipedia-LOD collection. The evaluation studies the effectiveness of answering a Jeopardy-style Natural Language question translated into a SPARQL-FT query with query processing techniques proposed in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>Preprocessing of the data collection before storing into Oracle 11g relational-DBMS, is done on a machine with Intel Xeon processor at 2.79 GHz. The machine has a main memory of 64 GB and secondary memory of 1 TB. To generate runs for the benchmark queries, we use a personal computer with Intel Core i3 processor at 3.30 GHz. This machine has a main memory of 8 GB and secondary memory of 200 GB. This machine is running a 64bit-Windows operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Measures</head><p>We use standard TREC metrics to measure the performance of all the runs. To compare our SPAR-Key engine variants we use the Mean-Average-Interpolated-Precision (MAiP), Precision at K (P@K), specifically P@5, P@10, P@15 and show plotting of the Average-interpolated-Precision values (AiP) at 11 standard points. We also perform a QA style evaluation with the Mean-Reciprocal-Rank (MRR) and Normalized-Discounted-Cumulative-Gain (NDCG) specifically, NDCG@5, NDCG@10 and NDCG @15. For further details on the metrics used to evaluate the run please refer to <ref type="bibr" coords="11,447.64,334.08,10.58,8.64" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experimental Runs</head><p>In this section we analyze our query engine based on the official evaluation results presented by the INEX. Table <ref type="table" coords="11,256.16,404.87,4.98,8.64" target="#tab_6">9</ref> shows the official INEX results over the Jeopardy topics. To generate the results, top-20 results from each run were pooled and assessed by crowd sourcing through the Crowdflower platform <ref type="foot" coords="11,342.02,427.11,3.49,6.05" target="#foot_0">3</ref> . For further details on the evaluation procedure please refer to the Overview paper of the INEX 2013 LOD track. We note that we were the only group that participated in the Jeopardy task this year and hence we cannot compare our results to any other competitor. However, we compare our own variants of the query processor based on the three runs (one from each variant) submitted to the INEX. We identify four classes of queries in the benchmark that: 1) target single entity as the only correct answer, 2) target combination of entities as the only correct answer, 3) target list of entities as correct answer and 4) target list of combination of entities as correct answer. In this evaluation we present the combined results of our engine over all the queries.</p><p>From the evaluation results we observe that by activating the phrase search component (described in Section 4.4) we obtain the best results in terms of MRR and NDCG values. This clearly supports our choice of recognizing the noun phrases as valuable features for the query processing. In addition, we find that the simpler Supremacy variant gives better performance than the Ultimatum-No phrase (though not significantly better) as the URI Search (described in Section 4.3) which is activated in the Ultimatum-No phrase becomes an overkill for most of the queries. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MPIUltimatum Phrase MPIUltimatum</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We presented an approach for storing structured RDF data and unstructured data in relational database. We also presented the necessary indices required to efficiently process queries over the relational schema. Our approach converts a SPARQL query with fulltext conditions into unions of conjunctive SQL queries by materializing temporary tables. These temporary tables store intermediate results from inner or outer joins over our relations, based on given conditions in the query. We also presented a simple yet effective way to rank entities by translating scores from keywords. In addition, we showed three variants of the query processor, each following different query processing strategies by recognizing a different set of features and score boosting to obtain the entity ranking. Finally we compared the variants based on the official evaluation released by the INEX and underline some of the key advantages and disadvantages of each query processing strategies. As a future work we would like to focus on the efficiency of the query processing and shifting the storage model from relational-DBMS to file system. Also we are keen in designing an automatic translator for translating a Jeopardy-style NL question into a SPARQL-FT query which can be then processed by our current system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="8,134.77,266.52,157.46,8.12;8,134.77,277.83,108.26,7.77;8,177.99,121.53,86.45,130.25"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. Snapshot of DBpedia class hierarchy [http://mappings.dbpedia.org]</figDesc><graphic coords="8,177.99,121.53,86.45,130.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="9,169.86,654.79,102.72,8.12;9,346.27,654.79,95.74,8.12;9,329.29,567.13,129.68,72.93"><head>Fig. 3 . 4 .</head><label>34</label><figDesc>Fig. 3. Chain query structure Fig. 4. Star query structure</figDesc><graphic coords="9,329.29,567.13,129.68,72.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" coords="12,134.77,333.37,345.83,175.91"><head></head><label></label><figDesc></figDesc><graphic coords="12,134.77,333.37,345.83,175.91" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="2,134.77,117.72,318.06,86.73"><head>Table 1 .</head><label>1</label><figDesc>Table schema the DBpediaCore table</figDesc><table coords="2,151.27,117.72,301.56,64.91"><row><cell></cell><cell></cell><cell>Attribute</cell><cell>Value</cell></row><row><cell>Column</cell><cell>Type</cell><cell>Number Of Rows</cell><cell>200187000</cell></row><row><cell>N3ID</cell><cell>NUMBER</cell><cell>Blocks</cell><cell>4288182</cell></row><row><cell>Subject</cell><cell>VARCHAR2(1024)</cell><cell cols="2">Distinct Rows Subject 18272256</cell></row><row><cell cols="2">Predicate VARCHAR2(1024)</cell><cell cols="2">Distinct Rows Object 26873856</cell></row><row><cell>Object</cell><cell>VARCHAR2(1024)</cell><cell cols="2">Distinct Rows Predicate 18310</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="2,309.04,185.37,112.03,19.08"><head>Table 2 .</head><label>2</label><figDesc>Table Summary of the DBpediaCore table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="2,141.74,620.65,188.30,44.43"><head>Table 3 .</head><label>3</label><figDesc>Table schema of the Keywords table</figDesc><table coords="2,141.74,620.65,188.30,44.43"><row><cell>8:</cell></row><row><cell>http://downloads.dbpedia.org/3.8/en/</cell></row><row><cell>-YAGO2 core and full dumps:</cell></row><row><cell>http://www.mpi-inf.mpg.de/yago-naga/yago/</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" coords="3,309.04,162.65,112.03,19.08"><head>Table 4 .</head><label>4</label><figDesc>Table Summary of the Keywords table</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" coords="4,134.77,117.72,345.83,265.23"><head>Table 5 .</head><label>5</label><figDesc>Schema of the DBpediaCore table</figDesc><table coords="4,134.77,117.72,345.83,265.23"><row><cell>Index Name</cell><cell>Attributes</cell></row><row><cell cols="2">DBpediaIDX Obj (Object,Subject,Predicate)</cell></row><row><cell cols="2">DBpediaIDX Sub (Subject,Predicate,Object)</cell></row><row><cell cols="2">DBpediaIDX Prd (Predicate,Object,Subject)</cell></row><row><cell cols="2">information consisting of attribute-value pairs that describe the entity, and of course rich</cell></row><row><cell cols="2">text contents consisting of unstructured information and more XML markup about the</cell></row><row><cell cols="2">entity that is captured by such an article. Our keyword indexer uses the basic function-</cell></row><row><cell cols="2">ality of TopX 2.0 [5], which includes Porter stemming, stopword removal and BM25</cell></row><row><cell cols="2">ranking, but stores the resulting inverted lists for keywords into the Keywords rela-</cell></row><row><cell cols="2">tional table instead of TopX proprietary index structures. Table 4 shows some statistics</cell></row><row><cell>of the Keywords table.</cell><cell></cell></row><row><cell cols="2">2.3 Indexes on the Relational Tables</cell></row><row><cell cols="2">We note that solving a complex SPARQL query, with one or more logical joins of</cell></row><row><cell cols="2">triples, employs multiple self joins of DBpediaCore table and also Keywords table.</cell></row><row><cell cols="2">This is a performance killer due to the colossal size of the tables. Relational-DBMS</cell></row><row><cell cols="2">systems provide a standard optimization by facilitating index creations over a relational</cell></row><row><cell>table.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" coords="10,134.27,237.38,356.11,339.83"><head></head><label></label><figDesc>1. Load the features index containing frequent terms and their IDF values into main memory. 2. Tokenize and stem the FTContains fulltext conditions and decide the order of joins among the keywords from the features index. 3. Analyze the Predicates in each triple and mark the bounded variables with their class. The domain of the Predicate will be marked for the Subject and Range will be marked for the Object. Thus we obtain a set: classSet = {{variable 1 , class 1 }, {variable 2 , class 2 }, {variable 3 , class 3 }, ...}. 4. Exploit the query structure to find most selective class for an entity place-holder and update the classSet. 5. Create Keys SearchU ri i tables containing results form a search on the entity URI for each term. 6. Create temporary Keys i tables for each fulltext condition: these contain the results of the OUTER join over the Keywords table instances constrained by the terms. Also add the class constraint on the bounded entity with the corresponding class value in classSet. 7. Create temporary Keys Search F inal i tables by performing a FULL OUTER JOIN on Keys SearchU ri i and Keys i . 8. Create temporary T ab i tables for each triplet pattern. These contain the results of the INNER join over the DBpediaCore table instances which are addition'ally joined with Keys Search F inal i temporary tables for each FTContains fulltext condition in the query. Also add the class constrains to the variables by selecting the class values from the classSet. 9. Assign a default score of 1 to all triples in absence of a fulltext condition. 10. Formulate the main select query that combines the T ab i temporary tables via an INNER join; the join logic is based on the joins given in the original SPARQL query. 11. Finally, drop the temporary tables Keys SearchU ri i , Keys i , Keys Search F inal i and T ab i .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" coords="12,139.23,117.92,336.89,404.25"><head>Table 9 .</head><label>9</label><figDesc>Jeopardy Task retrieval results.</figDesc><table coords="12,364.08,117.92,112.05,8.93"><row><cell>NoPhrase MPISupremacy</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0" coords="11,144.73,657.08,89.47,7.77"><p>https://crowdflower.com/</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="13,138.13,270.40,342.46,7.77;13,146.47,281.19,332.32,7.93" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="13,381.28,270.40,99.31,7.77;13,146.47,281.36,121.73,7.77">Running SPARQL-Fulltext Queries Inside a Relational DBMS</title>
		<author>
			<persName coords=""><forename type="first">Arunav</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Martin</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,286.67,281.19,165.72,7.73">CLEF (Online Working Notes/Labs/Workshop)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,292.15,342.47,7.93" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="13,225.51,292.31,192.57,7.77">Controlling overlap in content-oriented XML retrieval</title>
		<author>
			<persName coords=""><forename type="first">Charles</forename><forename type="middle">L A</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,433.68,292.15,20.54,7.73">SIGIR</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,303.11,342.46,7.93;13,146.47,314.07,201.56,7.93" xml:id="b2">
	<monogr>
		<author>
			<persName coords=""><forename type="first">M.-C</forename><surname>De Marneffe</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<ptr target="http://nlp.stanford.edu/software/dependenciesmanual.pdf" />
		<title level="m" coord="13,290.05,303.27,129.43,7.77">Stanford typed dependencies manual</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,325.19,342.46,7.77;13,146.47,336.15,334.12,7.77;13,146.47,346.95,310.41,7.93" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="13,225.60,336.15,255.00,7.77;13,146.47,347.11,13.84,7.77">Storing and Indexing Massive RDF Datasets Semantic Search over the Web</title>
		<author>
			<persName coords=""><forename type="first">Yongming</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Franc</forename><surname>Picalausa</surname></persName>
		</author>
		<author>
			<persName coords=""><surname>¸ois</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">George</forename><forename type="middle">H L</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,177.86,346.95,252.91,7.93">Semantic Search over the Web, Data-Centric Systems and Applications</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,358.07,342.46,7.77;13,146.47,368.87,137.77,7.93" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="13,346.12,358.07,134.47,7.77;13,146.47,369.03,76.49,7.77">TopX 2.0 at the INEX 2009 Ad-Hoc and Efficiency Tracks</title>
		<author>
			<persName coords=""><forename type="first">Martin</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Ablimit</forename><surname>Aji</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Ralf</forename><surname>Schenkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,239.66,368.87,17.73,7.73">INEX</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,379.82,342.46,7.93;13,146.47,390.78,84.77,7.93" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="13,307.94,379.99,142.42,7.77">RDF-3X: a RISC-style engine for RDF</title>
		<author>
			<persName coords=""><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="13,461.32,379.82,19.27,7.73;13,146.47,390.78,49.28,7.73">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,401.90,342.46,7.77;13,146.47,412.86,334.12,7.77;13,146.47,423.66,294.79,7.93" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="13,400.19,412.86,80.40,7.77;13,146.47,423.82,85.93,7.77">Overview of the INEX 2012 Linked Data Track</title>
		<author>
			<persName coords=""><forename type="first">Qiuyue</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Jaap</forename><surname>Kamps</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Georgina</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Camps</forename></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Maarten</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Anne</forename><surname>Schuth</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Martin</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Arunav</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,249.14,423.66,165.72,7.73">CLEF (Online Working Notes/Labs/Workshop)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="13,138.13,434.78,342.46,7.77;13,146.47,445.74,334.12,7.77;13,146.47,456.54,294.79,7.93" xml:id="b7">
	<analytic>
		<title level="a" type="main" coord="13,400.19,445.74,80.40,7.77;13,146.47,456.70,85.93,7.77">Overview of the INEX 2013 Linked Data Track</title>
		<author>
			<persName coords=""><forename type="first">Qiuyue</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Jaap</forename><surname>Kamps</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Georgina</forename><surname>Ramirez</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Camps</forename></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Maarten</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Anne</forename><surname>Schuth</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Martin</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Arunav</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="13,249.14,456.54,165.72,7.73">CLEF (Online Working Notes/Labs/Workshop)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
