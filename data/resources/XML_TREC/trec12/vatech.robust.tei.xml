<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,75.24,78.40,461.73,14.53">Ranking Function Discovery by Genetic Programming for Robust Retrieval</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,123.78,112.68,38.81,9.57"><forename type="first">Li</forename><surname>Wang</surname></persName>
							<email>liwang5@vt.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,171.60,112.68,52.06,9.57"><forename type="first">Weiguo</forename><surname>Fan</surname></persName>
							<email>wfan@vt.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,231.19,112.68,39.88,9.57"><forename type="first">Rui</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,279.16,112.68,40.06,9.57"><forename type="first">Wensi</forename><surname>Xi</surname></persName>
							<email>xwensi@vt.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,326.59,112.68,41.94,9.57"><forename type="first">Ming</forename><surname>Luo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,376.41,112.68,36.38,9.57"><forename type="first">Ye</forename><surname>Zhou</surname></persName>
							<email>yezhou@vt.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName coords="1,420.71,112.68,67.58,9.57"><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Fox</surname></persName>
							<email>fox@vt.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Virginia Polytechnic Institute and State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,75.24,78.40,461.73,14.53">Ranking Function Discovery by Genetic Programming for Robust Retrieval</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2D5386FB021AEA776532B205EFFF646E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-08-05T15:00+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ranking functions are instrumental for the success of an information retrieval (search engine) system. However nearly all existing ranking functions are manually designed based on experience, observations and probabilistic theories. This paper tested a novel ranking function discovery technique proposed in [Fan 2003a, Fan2003b]  -ARRANGER (Automatic geneRation of RANking functions by GEnetic pRogramming), which uses Genetic Programming (GP) to automatically learn the "best" ranking function, for the robust retrieval task. Ranking function discovery is essentially an optimization problem. As the search space here is not a coordinate system, most of the traditional optimization algorithms could not work. However, this ranking discovery problem could be easily tackled by ARRANGER. In our evaluations on 150 queries from the ad-hoc track of TREC 6, 7, and 8, the performance of our system (in average precision) was improved by nearly 16%, after replacing Okapi BM25 function with a function automatically discovered by ARRANGER. By applying pseudo-relevance feedback and ranking fusion on newly discovered functions, we improved the retrieval performance by up to 30%. The results of our experiments showed that our ranking function discovery technique -ARRANGER -is very effective in discovering high-performing ranking functions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Text resources in digital format are quickly increasing with the rapid development of the IT industry. This tremendous collection of resources serves as a rich repository for our society in general. However, it also brings challenges to the general public. How to use this repository effectively is one of the biggest challenges. Researchers have developed various information retrieval systems, also known as search engines, to help people quickly and accurately find what they need from this repository. The working process for an information retrieval (search engine) system can be simplified to the process of returning an ordered document list according to a user's information need (expressed as queries). Therefore the most critical part for an IR system is its ranking function, which is used to order documents based on their similarity degrees to a user query. Designing a good ranking function, however, is not an easy task. There are many well-known ranking functions, such as Okapi BM25, TFIDF, and INQUERY. But most of those ranking functions are manually designed by experts based on heuristics, experience, observations, and statistical theories. One novel part of our work is that we use a Genetic Programming (GP) based technique called ARRANGER (Automatic geneRation of RANking functions by GEnetic pRogramming) to discover ranking functions automatically <ref type="bibr" coords="1,342.80,581.81,102.57,9.57">[Fan 2003a, Fan2003b]</ref>. Ranking functions usually could not work consistently well under all situations. Various information retrieval studies have shown that the performance of a ranking function is very context-dependent <ref type="bibr" coords="1,423.04,607.13,116.98,9.57" target="#b4">[Salton &amp; Buckley, 1988;</ref><ref type="bibr" coords="1,72.00,619.79,95.24,9.57" target="#b5">Zobel &amp; Moffat, 1998</ref>]. The context may depend on text collections or even properties of queries. Using a static ranking function can not guarantee good performance under all situations. How to find the "optimal" ranking function for a specific context is quite a challenge. The advantage of ARRANGER is that it can learn the "optimal" ranking functions according to different contexts by effectively combining multiple types of evidence in an automatic and systematic way. Using 150 queries from the ad-hoc task of the Robust Track in TREC 6, 7, and 8, we found ranking functions discovered with ARRANGER improved the performance of our baseline system, which uses the Okapi BM25 ranking function, by 8 ~ 16%. Based on those newly discovered ranking functions, we also tried other performance improvement techniques such as pseudo-feedback (query expansion) and information fusion which combines scores from different ranking functions using a regression technique. These techniques altogether help improve our performance by up to 30% in average precision over the baseline Okapi system.</p><p>Our paper is organized as follows. Section 2 states our research objectives. Section 3 describes basic data processing steps. Section 4 reviews ARRANGER -a GP-based ranking function discovery technique. Section 5 summarizes other techniques used in our system and gives a detailed description of our final submissions. Section 6 shows the official submission results in comparison with the other TREC teams. We conclude our paper in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Research objectives</head><p>We have two objectives in this year's Robust Track:</p><p>1) We want to test the ARRANGER framework proposed in <ref type="bibr" coords="2,366.51,277.32,47.87,9.57">[Fan 2003a</ref><ref type="bibr" coords="2,414.37,277.32,53.37,9.57">, Fan 2003b</ref>] to see whether it can work well on more heterogeneous collections. 2) We want to test whether the newly discovered ranking functions can work well with other performance improvement techniques such as query expansion through blind feedback, and ranking fusion using logistic regression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Data processing</head><p>All our experiments were run on a two-2.3GHz processor Dell Server running the Linux operating system. Since our concentration in TREC is to test our GP-based ranking function discovery technique, ARRANGER, we didn't take advantage of the document structure. Past TREC results also showed that structure information didn't help in these data. In the parsing process, we simply removed the noninformative content in the collection and kept only the texts in the TEXT field. These texts were indexed into both forward index and inverted index formats for our experimental purposes after removing stop words and stemming. No phrases were used in our experiments.</p><p>For query processing, we indexed three different versions of the topic descriptions. The first version is description queries, which are generated based on the Description field only as required by the Robust Track. The second, short queries, are based on the Title and Description fields. The third, long queries, are extracted based on all fields from the topic description.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Ranking function discovery based on Genetic Programming</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Genetic Programming</head><p>Genetic Programming (GP), an extension of Genetic Algorithms (GA), is an artificial intelligence technique, inspired by Darwin's theory of evolution. "Computer programs that evolve in ways that resemble natural selection can solve complex problems even their creators do not fully understand" <ref type="bibr" coords="2,72.00,631.49,69.30,9.57" target="#b2">[Holland, 1975]</ref>. Genetic Programming has been widely used and approved to be effective in solving optimization problems, such as financial forecasting, engineering design, data mining, and operations management. GP makes it possible to solve complex problems for which conventional methods can not find an answer easily.</p><p>In Genetic Programming, a large number of individuals, called a population, are maintained at each generation. An individual represents a tentative solution for the target problem. All these solutions form a space, say, Σ. In reality, individuals could be stored using complex data structures, such as a tree, a linked list, or a stack. A tree is the most popular form to store and represent individuals. Figure <ref type="figure" coords="3,499.34,74.94,10.37,9.57">1a</ref> shows an example of a tree which represents the expression (X + Y)*Z. Now, as our target in TREC is to find an "optimal" ranking function to sort documents in the collection, individuals should represent tentative ranking functions. Figure <ref type="figure" coords="3,191.97,112.86,10.99,9.57">1b</ref> shows an individual representing a ranking function. A fitness function (f (•): Σ → R) is also needed in Genetic Programming. A fitness function takes the solution space, Σ, as its domain and returns a real number. Hence tentative solutions, represented by individuals, could be measured and ordered according to their return values. The return value of a fitness function must appropriately measure how well an individual, which represents a solution, can solve the target problem.</p><p>Figure1a. A simple expression represented by a tree Figure <ref type="figure" coords="3,362.26,320.76,9.16,9.57">1b</ref>. A simple ranking function Genetic Programming searches for the "optimal" solution by evolving the population generation after generation. Individuals in the new generation are produced based on those in the current one. Three genetic operators are usually used to produce the new generation. They are Reproduction, Crossover, and Mutation. The reproduction operator directly copies or, in a more appropriate term, clones some individuals into the next generation. The probability for an individual to be selected for Reproduction should be proportional to its fitness. Therefore the better a solution solves the problem, the higher probability it has to enter the next generation. While Reproduction keeps the best individuals in the population, Crossover and Mutation introduce transformation and so provide variations to enter into the new generation. The crossover operator randomly picks two groups of individuals, selects the best individual in each of two groups as parent according to their fitness, exchanges a randomly selected gene fragment of each parent and produces two "children". Thus, a "child" may obtain the good fragments of its excellent parents and may exceed them further, providing a better solution to the problem. Since parents are selected from a "competition", good individuals are more likely to be used to generate offspring. The mutation operator randomly changes a gene code, which could be a function or a parameter in our ranking function discovery task, of an individual. Figure <ref type="figure" coords="3,414.58,523.14,5.49,9.57">2</ref> shows how the Crossover operator works. Using these genetic operators, a new generation is produced. The new generation keeps individuals with the best fitness in the last generation and takes in more "fresher air", providing creative solutions to the target problem. Better solutions are obtained either by inheriting and reorganizing old ones or by lucky mutation, simulating Darwinian Evolution. As we can see, Genetic Programming takes a so-called stochastic search approach, intelligently, extensively, and "randomly" searching for the optimal point in the entire solution space. It is less likely to be trapped in the local optima, which is the major problem of many other search algorithms. It provides sound solutions to many arduous problems, for which people have not found a theoretical or practical breakthrough. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Motivation for using Genetic Programming ranking function discovery</head><p>A ranking function plays an essential role in an IR system (or search engine). It evaluates the similarity degree of a document to the query, so documents can be ranked according to its returned value. However, many empirical studies have shown inconsistent performance by existed well-known ranking functions on various collections <ref type="bibr" coords="4,221.66,138.18,118.16,9.57" target="#b4">[Salton &amp; Buckley, 1988;</ref><ref type="bibr" coords="4,344.27,138.18,99.74,9.57" target="#b5">Zobel &amp; Moffat, 1998</ref>]. The same ranking function may work well on one collection, but poorly on others. They are collection-sensitive, and sometimes even query-sensitive. Given a specific context, how to select the right one from available ranking functions or how to design a new function for a given context has not been fully studied before.</p><p>Nearly all the existed ranking functions are manually designed, based on experience, heuristics and probability theory. Some parameters in these functions are usually adjusted to accommodate collection differences. However, these functions should still be categorized as static ranking functions, since the function structure is untouched and the effect of such adjustment is limited. Our GP-based ranking function discovery approach provides a framework which could automatically learn the "optimal" ranking function for the given context. As the structures of discovered ranking functions are not constrained, these customized functions could provide striking performance on the target collection where static ranking functions can not.</p><p>Ranking function discovery is essentially an optimization problem. We are looking for the global optimal point in the space, which consists of all the possible ranking functions. However this task is completely different from the traditional high-dimension optimization problem, since the space of ranking functions is no longer a coordinate system (As in Abstract, make this clearer. Do you mean a vector space or metric space or measure space?). Conventional approaches for solving optimization problems, such as conjugate gradient, linear programming, nonlinear programming, and simulated annealing, can hardly work here. Also the ranking function space consists of an infinite number of elements, which makes it impossible to get the "optimal" point for random search and exhaustive search. As we showed before, functions could be expressed by trees. We can actually treat the ranking function space as a space consists of all kinds of tree structures. Genetic Programming shows its sharp edge in solving such kind of problems, since its internal tree structure representation for "individuals" can be perfectly used for describing ranking functions. This is the major motivation to choose GP for the ranking function discovery task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Outline of our GP-based ranking function discovery system -ARRANGER</head><p>In this section, we give a brief introduction to the ARRANGER engine. Please refer to <ref type="bibr" coords="5,519.84,214.08,20.15,9.57;5,72.00,226.74,24.70,9.57">[Fan 2003a</ref><ref type="bibr" coords="5,96.70,226.74,52.86,9.57">, Fan 2003b</ref>] for a more detailed introduction and for validation.</p><p>Basically a ranking function consists of three parts: variables, constants, and operations (which connect the first two parts). Hence we need to identify all the potential variables that are used in the ranking function by ARRANGER. Some examples for these variables are tf, tf_query, tf_max, length, N, tf_avg, tf_Avg_Col, df_max_Col, df, etc. Table <ref type="table" coords="5,287.71,277.32,5.49,9.57">1</ref> gives the meaning of these variables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. Definitions for variables</head><p>There are two different types of variables, scalar and vector. Some of these predefined variables are summaries calculated for the whole collection or a specific document, such as tf_max, N, tf_Avg_Col, etc. These variables belong to the category of scalar variable. The remaining variables have vector nature, such as tf_doc and tf_query. We defined that when such variables appear in a ranking function, they represent vectors, instead of single numbers. For example, if a query has n words in it, tf_doc could be represented by (x 1 , x 2 ,…, x n ), where x i ( i = 1,2,…,n ) is the term frequency (tf) of the query's ith word in the document. For constants, they are defined to be scalar only. Based on pre-selected variables and constants, we define two types of functions (operations), single-parameter functions (denoted by σ(•)) and two-parameter functions (denoted by ○). Single-parameter functions include log( ) and sqrt( ). Twoparameter functions include +, -, *, /. Some functions, such as log( ), sqrt( ) and /, need to be protected, since the domain of these functions is not the whole real number space. As a variable could be a scalar or a vector, those functions must take that into consideration. For one-parameter functions, we define σ(x) = y and σ( (x 1 , x 2 ,…, x n ) ) = (σ (x 1 ), σ (x 2 ),…, σ (x n )), where x, y and x i represent scalar variables and (x 1 , x 2 ,…, x n ) is used to represent vectors. For two-parameter functions, we define</p><p>x ○ y = z, x ○</p><formula xml:id="formula_0" coords="6,72.00,94.80,467.91,29.72">(x 1 , x 2 ,…, x n ) = (x ○x 1 , x ○x 2 ,…, x ○x n ) and (x 1 , x 2 ,…, x n ) ○ (y 1 , y 2 ,…, y n ) = (x 1 ○ y 1 , x 2 ○ y 2 ,…, x n ○ y n )</formula><p>, where x, y, z, x i and y i represent scalars and (x 1 , x 2 ,…, x n ) represent a vector. Following our definitions for variables and functions, when a vector variable appears in the ranking function, the final result also is a vector, where a scalar usually is needed to measure the similarity degree between a document and a query. In this case, we further define that the return value of a ranking function is the summation of all the elements when a vector is finally returned by that function. Based on all those rules defined by us, the ARRANGER could work on discovering ranking functions. Also when we plug in the newly-discovered functions into our search engine, the same rules must be followed. Queries in the TREC 6, 7, and 8 Ad-Hoc task (topic 301-450) are used to discover ranking functions. According to the procedure described in section 3, the collection is first processed into dictionary and inverted files, such that our search engine can work on them. For each query, the search engine returns the top 5000 document names using an arbitrary function. Any popular ranking functions, which have been proved effective, could be used for this purpose. We used the Okapi BM25 ranking function for this first scan. On average more than half of all the relevant documents are listed in the top 5000 documents for each query. Therefore those documents have included enough relevant documents, whose properties could be learned later. According to the relevance judgments, those documents are separated into two groups, relevant and nonrelevant. Each group needs to be randomly divided into three parts, called training, validation, and testing data set. Then we randomly combine the relevant and nonrelevant documents associated with each data set. Now the training, validation, and testing sets all include relevant and nonrelevant documents in random order. The fitness value for a ranking function is the average precision we could get in our system when using that function.</p><p>The framework of ARRANGER works as follows: First, the best ranking functions learned from the training set are stored and the rest are discarded. Then those functions are tested on the validation set. According to their performance, the functions which do not have consistent performance on both data sets are screened out. Finally, "survived" functions are tested again on the test data set. The same screening rule follows. Only the most robust and consistent functions are selected and they form the ranking function candidate pool. Since an appropriate stopping rule is hard to find for the Genetic Programming approach, over-training is inevitable unless protecting rules are set. By running the ranking functions on two other independent data sets, over-trained functions are filtered out once performance inconsistencies appear.</p><p>We used ARRANGER to discover "optimal" functions on the Robust Track collection. We tested the automatically learned functions on three types of queries: description query, short query, and long query as described in the Section 3. Table <ref type="table" coords="6,290.89,508.37,5.49,9.57">2</ref> shows the results on the entire collection. From this table, you can see that significant improvement is achieved by replacing the Okapi BM25 function with our newly-discovered functions. Table <ref type="table" coords="6,100.95,663.72,4.12,9.57">2</ref>. Performance comparison of Okapi BM25 and GP functions on 150 queries of Ad-Hoc task at TREC 6, 7, and 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Other performance improvement techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Pseudo-relevant feedback</head><p>Pseudo-relevance feedback (automatic query expansion) is the process of adding more terms to a user's query to promote performance of search engines. It is a widely-used and effective technique, especially for very short queries. In pseudo-relevance feedback, a small number of documents are first retrieved according to the user's query and these documents are assumed to be relevant. Words in those documents as well as words in the original query are sorted according to a weighting function. An expanded query is generated by selecting some words from this list. There are many variations in using different weighting functions and strategies to select words for the new query.</p><p>We apply various pseudo-relevance feedback techniques, based on new functions discovered by our ARRANGER. They are Rocchio, Ide dec-hi, CHI, KLD, RSV, DRC, and a variation of KLD, which we deduced by probability theory. Those techniques are applied on both description queries and long queries. They provide significant performance improvement on both types of queries. As we expected they improve more on description queries than long queries. For each approach, there are several parameters to be adjusted, for example, the number of documents assumed relevant, the number of terms for the expanded query, and parameters in the weighing function. A factorial design was used to look for the "best" parameter settings, which provides at the same time a high performance mean and low performance variation for ad-hoc tasks in TREC 6, 7, and 8. After comparison, we found Rocchio and Ide dec-hi are the best query expansion schemes on our automatically learned functions. Table <ref type="table" coords="7,507.61,340.55,5.49,9.57" target="#tab_2">3</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Rank fusion -combine scores from different ranking functions</head><p>Since many high quality ranking functions have been learned, an old saying "two heads are better than one" could be used in our system to further improve performance. In our experiment, three GPbased functions and Okapi BM25 are combined to produce a new ranking function. Because the relevance judgment only provides binary relevant (1) and nonrelevant (0) information, logistic regression is an appropriate tool to find such a relationship. Let p denote the probability that a document is relevant to the query and let gp1, gp2, gp3, and okp represent scores returned by our three GP-based functions and the Okapi BM25 function for this document, respectively. Our initial model is logit(p) = 0</p><formula xml:id="formula_1" coords="7,190.68,605.01,225.83,17.26">β + 1 β *gp1 + 2 β *gp2+ 3 β *gp3+ 4 β *okp + INT</formula><p>INT includes all the possible two factor, three factor, and four factor interactions. Only after including interaction terms, the similarity degree between a document and query could be appropriately measured when conflict scores are given by different ranking functions. Otherwise a main-effect-only model can not fit the data well.</p><p>For each of 150 queries, the search engine generates names and scores of the top 300 documents returned by these four ranking functions. A union operation is applied on all the returned documents, therefore we generate a huge matrix with 5 columns (gp1 score, gp2 score, gp3 score, okp score, and relevance information). If a document was not listed in the top 1000 list by a function, its score associated with this function is assigned to 0. The performance of the combined function is superior to all other functions from which it is generated. Another appealing property we found in experiments is that the combined function produces the smallest performance variation on TREC 6, 7, and 8 among all the ranking functions. Experiments show that our ranking function fusion approach improves not only the performance but also the consistency of the information retrieval system, although the difference is not statistically significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Results</head><p>We submitted five independent runs for this year's Robust Track. Our submissions do not involve any human intervention, so they are all automatic runs. The first four runs use all the topic fields and the last one only uses the description field of topics. Table <ref type="table" coords="8,353.95,421.20,5.49,9.57" target="#tab_4">5</ref> gives the detailed description of our submissions. Table <ref type="table" coords="8,159.02,433.80,5.49,9.57">6</ref> summarizes the final evaluation results from TREC for all 5 runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Run Number Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VTcdhgp1</head><p>In this run, we first search long queries (all fields of topics) against Robust collection, using a linearly combined ranking function (combining 3 GP functions we derived from experiments with Okapi). Secondly, we assume the top 6 documents are relevant and use Ide dec-hi approach to "expand" the description field of each query to 22 words. Finally, we search the "expanded query" against the Robust collection again using a GP ranking function, which we derived from previous experiments. VTgpdhgp2</p><p>Same as VTcdhgp1 except that we use GP ranking function for the first search and expand the query to 14 words instead of 22 words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VTcdhgp3</head><p>Same as VTcdhgp1 except that we expand the query to 23 words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VTgpdhgp4</head><p>Same as VTcdhgp2 except that we expand the query to 17 words.</p><p>VTDokrcgp5 In this run, we first search description field of queries against Robust collection using Okapi BM25 ranking function. Secondly, we assume the top 8 documents are relevant and use Rocchio method to "expand" the description field of each query to 22 words. Finally, we search the "expanded query" against the Robust collection again using a GP ranking function, which we derived from previous experiments. In total, we contribute 14 queries that have the best performance among 100 queries Table <ref type="table" coords="9,142.69,225.96,4.12,9.57">6</ref>. Official submission results. The last run is based on the description field only.</p><p>As can be seen from Table <ref type="table" coords="9,194.96,251.22,4.12,9.57">6</ref>, we contribute 14 queries that have the best performance in 100 topics. Our last run based on the description field performs even better than the median submission run (MAP= 0.2387, P10 = 0.3990). Our best run trails by 12% in MAP and 8% in P10 from the best team. We consider the performance results very satisfactory considering the fact that we had a relatively low baseline system. We are currently in the process of improving the parsing and indexing process to improve the baseline performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>In this paper, we used ARRANGER, a GP-based discovery engine, to discover several ranking functions for the Robust Track. We observed up to 16% performance improvement over our baseline Okapi system. The experimental results show that the automatically learned ranking functions are capable of outperforming expert-designed functions.</p><p>In addition, we also tried some other popular performance improvement techniques, such as pseudo-relevance feedback and a ranking fusion technique. Both of them work well with those new functions and help further improve our system performance. Not only do they increase the average precision, but they also make the system more robust and provide less performance variation on different query sets.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="4,88.20,497.94,411.50,9.57;4,88.20,510.60,66.01,9.57"><head></head><label></label><figDesc>Figure 2. A simple example shows how the Crossover operator works in our ranking function discovery task.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="5,112.26,303.11,6.72,9.57;5,213.90,303.11,208.34,9.57;5,112.26,321.00,37.20,9.57;5,213.87,321.00,190.05,9.57;5,112.26,338.88,31.05,9.57;5,213.88,338.88,235.01,9.57;5,112.26,356.82,31.13,9.57;5,213.84,356.82,217.20,9.57;5,112.26,374.70,52.50,9.57;5,213.87,374.70,254.75,9.57;5,112.26,392.58,7.93,9.57;5,213.91,392.58,207.74,9.57;5,112.26,410.52,28.10,9.57;5,213.87,410.52,250.17,9.57;5,112.26,428.40,49.50,9.57;5,213.85,428.40,297.05,9.57;5,213.90,441.06,32.95,9.57;5,112.26,454.20,54.92,9.57;5,213.87,454.20,260.91,9.57;5,213.90,466.86,32.95,9.57;5,112.26,480.00,9.15,9.57;5,213.88,480.00,219.25,9.57;5,252.00,511.56,31.92,9.57"><head></head><label></label><figDesc>tf Query term frequency in the document (vector) tf_query Query term frequency in the query (vector) tf_max The maximum term frequency in a document (scalar) Length Document length in the number of words (scalar) Length_avg Average document length in the number of words (scalar) N Number of documents in the collection (scalar) tf_avg Average term frequency in the current document (scalar) tf_avg_Col Average term frequency for all the documents in the collection (scalar) df_max_Col Maximum document frequency for a word in the collection (scalar) df Document frequency for the query words (vector)Table 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" coords="7,72.00,340.55,468.12,112.78"><head></head><label></label><figDesc>gives the performance comparisons.</figDesc><table coords="7,77.40,379.01,462.72,74.32"><row><cell></cell><cell>Description</cell><cell>query</cell><cell>(average</cell><cell>Long query (average precision on</cell></row><row><cell></cell><cell cols="2">precision on 150 queries)</cell><cell></cell><cell>150 queries)</cell></row><row><cell>GP function 1 without QE</cell><cell cols="2">0.2173 (+15.6%)</cell><cell></cell><cell>0.2394 (+9.1%)</cell></row><row><cell>(baseline)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>GP function 1 + Rocchio</cell><cell cols="2">0.2422 (+28.9%)</cell><cell></cell><cell>0.2661 (+ 12.0%)</cell></row><row><cell>GP function 1 + Ide Dec-Hi</cell><cell cols="2">0.2390 (+27.1%)</cell><cell></cell><cell>0.2744 (+15.5%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="7,154.80,469.56,302.35,9.57"><head>Table 3 .</head><label>3</label><figDesc>-The effects of pseudo-relevance feedback on performance</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" coords="8,72.00,87.60,468.08,191.37"><head>Table 4 .</head><label>4</label><figDesc>After model selections, we achieved such a model: logit(p) = Performance comparison between combined function and other functions</figDesc><table coords="8,72.00,96.57,468.08,168.24"><row><cell>0 β +</cell><cell cols="3">1 β *gp1 + 2 β *gp2+ 3 β *gp3+ 4 β *okp + 5 β *gp1:gp2 + 6 β * gp1:gp3 + 7 β * gp2:okp</cell></row><row><cell cols="4">+ 8 β *gp1:gp3:okp + 9 β *gp2:gp3:gp4+ 10 β *gp1:gp2:gp3:okp, where X:Y represents the interaction</cell></row><row><cell cols="4">between factor X and Y. All i β 's are highly significant (with p-value &lt; 10 5 -) in this model. The</cell></row><row><cell cols="4">combined ranking function is then tested on the whole collection and the result is shown in Table 4.</cell></row><row><cell></cell><cell></cell><cell>150 queries (long)</cell><cell>50 test old queries (long)</cell></row><row><cell cols="2">Okapi BM25</cell><cell>0.2375</cell><cell>0.1251</cell></row><row><cell cols="2">GP1 function</cell><cell>0.2620</cell><cell>0.1393</cell></row><row><cell cols="2">GP2 function</cell><cell>0.2602</cell><cell>0.1334</cell></row><row><cell cols="2">GP3 function</cell><cell>0.2607</cell><cell>0.1346</cell></row><row><cell cols="2">Comb function</cell><cell>0.2666</cell><cell>0.1417</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" coords="8,202.08,695.10,230.35,9.57"><head>Table 5 .</head><label>5</label><figDesc>Description of our five official submissions</figDesc><table coords="9,87.78,85.56,416.22,96.75"><row><cell>Run No.</cell><cell>MAP</cell><cell>P10</cell><cell>#&gt;Median</cell><cell>#Best</cell></row><row><cell>VTcdhgp1</cell><cell>0.2649</cell><cell>0.432</cell><cell>62</cell><cell>3</cell></row><row><cell>VTgpdhgp2</cell><cell>0.2731</cell><cell>0.449</cell><cell>69</cell><cell>3</cell></row><row><cell>VTcdhgp3</cell><cell>0.2637</cell><cell>0.432</cell><cell>61</cell><cell>2</cell></row><row><cell>VTgpdhgp4</cell><cell>0.2696</cell><cell>0.448</cell><cell>65</cell><cell>2</cell></row><row><cell>VTDokrcgp5</cell><cell>0.2563</cell><cell>0.408</cell><cell>60</cell><cell>4</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0" coords="1,77.76,711.09,269.62,8.74"><p>Li Wang is now at the University of Michigan (wang@umich.edu).</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct coords="9,72.00,510.23,468.11,9.57;9,72.00,522.83,438.08,9.57" xml:id="b0">
	<analytic>
		<title level="a" type="main" coord="9,251.20,510.23,288.91,9.57;9,72.00,522.83,169.15,9.57">A generic ranking function discovery framework by genetic programming for information retrieval</title>
		<author>
			<persName coords=""><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Pathak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="9,251.94,522.83,180.89,9.57">Information Processing and Management</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct coords="9,72.00,541.49,468.04,9.57;9,72.00,554.15,468.00,9.57;9,72.00,566.81,129.60,9.57" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="9,253.03,541.49,287.02,9.57;9,72.00,554.15,225.76,9.57">Discovery of context-specific ranking functions for effective information retrieval by Genetic Programming</title>
		<author>
			<persName coords=""><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Pathak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="9,316.80,554.15,223.20,9.57;9,72.00,566.81,52.40,9.57">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct coords="9,72.00,585.47,467.98,9.57;9,72.00,598.07,24.75,9.57" xml:id="b2">
	<monogr>
		<title level="m" type="main" coord="9,136.20,585.47,276.67,9.57">Adaptation in Natural and Artificial Systems, the University of</title>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">H</forename><surname>Holland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>Michigan Press</publisher>
			<pubPlace>Ann Arbor</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,72.00,616.73,467.98,9.57;9,72.00,629.39,468.01,9.57;9,72.00,642.05,119.83,9.57" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="9,441.30,616.73,75.30,9.57">Okapi at TREC-4</title>
		<author>
			<persName coords=""><forename type="first">S</forename><forename type="middle">E</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">M</forename><surname>Hancock-Beaulieu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Gatford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="9,173.16,629.39,235.97,9.57">Proceedings of the Fourth Text Retrieval Conference</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Harman</surname></persName>
		</editor>
		<meeting>the Fourth Text Retrieval Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="500" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,72.00,667.37,468.09,9.57;9,72.00,679.97,232.19,9.57" xml:id="b4">
	<analytic>
		<title level="a" type="main" coord="9,208.83,667.37,263.48,9.57">Term weighting approaches in automatic text retrieval</title>
		<author>
			<persName coords=""><forename type="first">G</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Buckley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="9,487.50,667.37,52.59,9.57;9,72.00,679.97,125.56,9.57">Information Processing and Management</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="513" to="523" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="9,72.00,705.29,406.96,9.57" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="9,183.19,705.29,130.78,9.57">Exploring the similarity space</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="9,325.80,705.29,57.48,9.57">SIGIR Forum</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="18" to="34" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
