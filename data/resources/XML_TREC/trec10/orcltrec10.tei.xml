<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" coord="1,188.97,86.19,234.34,8.96">Oracle at TREC 10: Filtering and Question-Answering</title>
				<funder ref="#_z6K93sn">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,193.05,112.35,58.15,8.96"><forename type="first">Shamim</forename><surname>Alpha</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Corporation</orgName>
								<address>
									<addrLine>500 Oracle Parkway M/S 4op8</addrLine>
									<postCode>94065</postCode>
									<settlement>Redwood Shores</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,258.25,112.35,43.09,8.96"><forename type="first">Paul</forename><surname>Dixon</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Corporation</orgName>
								<address>
									<addrLine>500 Oracle Parkway M/S 4op8</addrLine>
									<postCode>94065</postCode>
									<settlement>Redwood Shores</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,308.37,112.35,38.07,8.96"><forename type="first">Ciya</forename><surname>Liao</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Corporation</orgName>
								<address>
									<addrLine>500 Oracle Parkway M/S 4op8</addrLine>
									<postCode>94065</postCode>
									<settlement>Redwood Shores</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,353.17,112.35,65.82,8.96"><forename type="first">Changwen</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Corporation</orgName>
								<address>
									<addrLine>500 Oracle Parkway M/S 4op8</addrLine>
									<postCode>94065</postCode>
									<settlement>Redwood Shores</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" coord="1,188.97,86.19,234.34,8.96">Oracle at TREC 10: Filtering and Question-Answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0AB31ECF408EE88DF22C09EEC1DD063C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-08-05T14:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Oracle's objective in TREC-10 was to study the behavior of Oracle information retrieval in previously unexplored application areas. The software used was Oracle9i Text[1], Oracle's full-text retrieval engine integrated with the Oracle relational database management system, and the Oracle PL/SQL procedural programming language. Runs were submitted in filtering and Q/A tracks. For the filtering track we submitted three runs, in adaptive filtering, batch filtering and routing. By comparing the TREC results, we found that the concepts (themes) extracted by Oracle Text can be used to aggregate document information content to simplify statistical processing. Oracle's Q/A system integrated information retrieval (IR) and information extraction (IE). The Q/A system relied on a combination of document and sentence ranking in IR, named entity tagging in IE and shallow parsing based classification of questions into pre-defined categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Filtering based on Theme Signature</head><p>As a first time filtering track participant, Oracle submitted runs for adaptive filtering, batch filtering and routing this year. Only linear-utility optimized runs were submitted for adaptive filtering and batch filtering. The filtering system is built based on the Oracle 9i database with PL/SQL -an Oracle supported database access language. Since the routing sub-task outputs the top 1000 ranked documents per category, and the training process and similarity score calculation algorithm are the same for batch filtering and routing, we will focus our discussion on batch filtering and adaptive filtering. The filtering system can be divided into three parts based on functionality: a. Theme Vector Generation b. Training c. Classification</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
		<surface n="11" ulx="0.0" uly="0.0" lrx="612.0" lry="791.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theme Vector Generation</head><p>Theme vector generation generates a theme vector for each document. It is built-in functionality of Oracle Text, the information retrieval component of the Oracle database <ref type="bibr" coords="1,356.24,538.23,12.14,8.96" target="#b1">[2]</ref>. A theme vector containing a list of themes (concepts) and associated weights carries all information of a document used in classification. Themes are normalized words having meanings individually and extracted based on the Oracle Text knowledge base. The knowledge base is built in-house and contains about 425 thousand concepts classified into 2000 major categories. These categories are organized hierarchically under six top terms: business and economics, science and technology, geography, government and military, social environment, and abstract ideas and concepts. This knowledge base is built to support concept search and retrieval. For this TREC work, the ConText knowledge base was employed in our filtering system to preprocess documents and generate concept terms. Although the Oracle Text user extensible knowledge base functionality allows users to modify the built-in knowledge base using user specified thesaurus, we used the knowledge base without any modification. We believe augmenting the knowledge base using domain specific information could improve filtering performance. In the theme generation, known phrases are recognized using a greedy algorithm, unknown words and proper name phrases are recognized and treated as themes. Words and phrases are normalized to their canonical forms. Every normalized term is a potential theme for a document.</p><p>Theme weights are used to rank the semantic significance of themes to the aggregate document content. Themes are assigned initial weights based on their lexical flags in the knowledge base. Next, several factors derived from the structure of a document and the frequency of the theme in the document are employed to modify the initial weights of the themes. For example, the first few terms inside a sentence have higher weights than the terms at the end of sentences to account for "fronting" and sentence focus. Generated theme vectors are normalized to have unity length before being sent to the training or classification process. This normalization can be written as : where w j n and w j are the j-th component (j-th theme term) weight of theme vector w after and before unity normalization respectively.</p><p>Our prior experience demonstrates that themes are superior to text tokens in representing text documents of medium to large size for classification purposes. Oracle Text first tokenizes documents and then processes these tokens using a greedy maximal match algorithm to generate themes. A brief description of the process to generate themes from tokens may shed some lights on the reason why themes are superior to tokens in classification. After finding a token, Oracle Text gets the part of speech information from the knowledge base or finds phrases based on the greedy algorithm and lexical knowledge base. If the token is a noun, a canonical form is used as a normalized form for this token, such as "tastefulness" with canonical form of "tasting" and "dull-headedness" with canonical form of "stupidity". If the token is a non-noun, a base form is found based on the knowledge base or morphology if the token does not exist in knowledge base. After that, a normalized noun form is used as the theme form for the non-noun base form. For example, "steadied" has a base form of "steady" which corresponds to a normalized form of "steadiness". The following differences between themes and tokens may contribute to the different behaviors in classification:</p><p>1. Themes can handle phrases while tokens can not without a lexicon. 2. Themes are represented with normalized forms of concepts, while tokens are forms with or without stemming. Word normalization is mostly based on lexical knowledge, while stemming of a token is mostly based on morphology. 3. The weight of a theme expresses the lexical information of a term, locations in a document, and term frequency. The weight of a token typically only includes the information of term frequency.</p><p>For the classification task no parent themes (broader terms) were used. Whether or not the parent themes improve the learning quality is actually an open question. One side says a specific word should be more important for representing a document and a parent theme may act as a common word. On the other hand, one of the parent themes may tell exactly what a document is about. However, that might depend on the level of parent theme and depend on whether or not the hierarchy of the knowledge base represents the same knowledge hierarchy in the classification application. We intend to investigate this issue thoroughly in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Training</head><formula xml:id="formula_0" coords="2,270.81,213.79,69.30,42.99">w j n w j w j 2 ∑ ------------------ =</formula><p>The training process calculates the summation of all relevant theme vectors for each category. The summation result serves as the original theme vector for one category. Because of accumulation, the number of themes in the category theme vector can be large. Experiments show that reducing some common themes and less frequent themes for the category theme vector can improve classification accuracy. Theme reduction can also reduce the resource usage and improve classification performance. We adopt a two-step theme reduction. The first step is to choose the top 400 themes with highest theme weights in the category theme vector. As mentioned earlier, the theme weight obtained from Oracle Text combines information about the lexical significance, word position inside one sentence, and occurrence frequency inside the document. Those top 400 themes in the category theme vector are the most frequently occurring and significant words to the category. Another rationale for choosing the theme by weights is that words with little meaning have lower weights and therefore can be removed.</p><p>The first step of theme selection based on the theme weight may choose some themes which are common in lot of categories. These common themes are not specific to one category and may produce extra noise to the classification process. The second step of theme reduction is to choose themes which are more specific to one category. We use a chi-square test for theme selection <ref type="bibr" coords="3,333.61,269.07,10.57,8.96" target="#b2">[3]</ref>. In specific, we choose a theme if the null hypothesis that this theme is independent of the considered category can be proved not true. The themes will be chosen if:</p><p>where N is the total number of training documents R is the number of training documents in this category n t is the number of training documents containing this word r t is the number of training documents in this category and containing this word. value 3.84 is chosen because the confidence of chi-square test is 0.95.</p><p>By chi-square test, the average theme vector size can be reduced to 280. In the original category theme vector, the weight is the summation of each document's theme weights; those weights help us to choose the top 400 themes for the category. However, during the classification process, we use Robertson-Sparck Jones weights <ref type="bibr" coords="3,124.49,528.15,11.61,8.96" target="#b3">[4]</ref> as term weights in category theme vectors. The weights are calculated based on the statistical characteristics of the training set and relevant category:</p><p>This formula is obtained from the Bayesian statistical model. The Robertson-Sparck Jones weight is the component weight for one term to estimate the log-odds of an given document belonging to the considered category in the assumption that terms are independent <ref type="bibr" coords="3,308.47,691.59,10.58,8.96" target="#b4">[5]</ref>. <ref type="figure" coords="3,237.93,604.03,151.72,10.80;3,385.77,604.03,4.00,10.80;3,221.13,604.03,15.36,10.80">----------------------------------------------------------------------------log</ref> Classification Before classification, category theme vectors are normalized to have unity length. In classification, the similarity scores S between the incoming document and each category are calculated as a dot product between the document theme vector vd and category theme vector vc, that is S = vd.vc. The document is classified to the categories in which the similarity scores are larger than the corresponding category thresholds. The predefined thresholds are determined from the relevance information either from the training set in batch filtering or from feedback in adaptive filtering.</p><formula xml:id="formula_1" coords="3,237.93,343.76,151.84,281.94">N Nr t n t R - ( ) 2 Rn t N R - ( ) N n t - ( ) ------------------------------------------------3.84 &gt; r t 0.5 + ( ) N R - n t - r t 0.5 + + ( ) n t r t - 0.5 + ( )R r t - 0.5 + ( )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Threshold Determination</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Batch filtering</head><p>Each category has its own threshold to determine if a document can be classified to it based on the similarity score. In order to determine the threshold for one category, we use the classification module to calculate the similarity score between all training documents and the considered category. For any given threshold x, we can get the following contingency table as we know the actual categories of each training document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relevant Not Relevant</head><formula xml:id="formula_2" coords="4,90.09,308.31,262.08,26.16">Retrieved R + N + Not Retrieved R - N -</formula><p>We can define a utility (goal) function of the about 4 numbers, say f(R + ,N + ,R -,N -,x). x appears explicitly in the function because R+,R-,N+ and N-are all functions of the threshold x. The threshold is chosen to maximize the function f. Threshold = x: max f(R + ,N + ,R -,N -,x)</p><p>x</p><p>In TREC-10, we submit the batch filtering run based on optimization function of linear-utility, which is f(R + ,N + )=T10U=2R + -N + .</p><p>In implementation, one can generate a sorted array of training documents ordered by similarity scores to the given category with a decreasing sequence. The relevance information of documents in the sorted array before any given document can determine R + , N + at the threshold value equal to the similarity score of this document. For each document in the sorted array, one then can calculate the T10U function value at the threshold value equal to the similarity score of this document based on calculated R + , N + . Because the array is sorted such that the similarity scores are decreasing, one therefore can draw a curve of T10U vs threshold. As threshold decreases from the largest value, the T10U values first increase because more relevant documents are located at the positions having larger similarity scores, and decrease after reaching a peak. The peak position corresponds to a similarity score , whose value is the optimized threshold value to maximize T10U function. This calculation makes the assumption that the training set similarity score distribution and T10U quantity is similar to that of the test set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Adaptive training</head><p>In adaptive filtering, we first built initial category theme vectors from training process of an initial training set, which contains two relevant documents per category. The training process is the same as we discussed above. The initial category threshold is set to be 40% of the minimum similarity score of the two relevant documents with the considered category. We then classify the test documents in a batch mode with each batch containing 2000 documents coming from the test set stream. After classification of each batch, feedback information including the relevance judgments and the similarity scores is sent to adaptive training, see Fig. <ref type="figure" coords="5,105.61,99.27,3.88,8.96" target="#fig_0">1</ref>.</p><p>Adaptive training includes updating category theme vectors and category thresholds. In order to update the category theme vector, we have to maintain the original category theme vectors which are the theme vectors before any theme selections and has the theme weights from summation of Oracle Text theme weights. To keep the number of themes in the category theme vector from becoming too large, we limit the size of each original category theme vector to a maximum of 2000. The extra feedback training document theme vectors are added to the original category theme vectors using Widrow-Hoff algorithm <ref type="bibr" coords="5,407.45,190.71,10.58,8.96" target="#b5">[6]</ref>.</p><p>where w j , w n j are the weights for j-th component of the category theme vector before and after adaptive training, respectively. x i is the theme vector of i-th feedback document, y i the relevance judgment of the i-th feedback document with the considered category with y i =0 denoting not relevant, y i =1 denoting relevant.</p><p>w.x i denotes the dot product between the theme vector w and x i . z&gt;0 is learning rate and is set to 0.2.</p><p>The Widrow-Hoff algorithm generates a list of updated themes and weights. We maintain only the top 2000 highest weight themes for each category. The weights here are calculated quantities from Oracle Text theme weights. We apply theme selections and employ Robertson-Sparck Jones weights as category theme vector weights for classification as discussed in the above training section.</p><p>Thresholds can be calculated based on the relevance information and similarity scores of all previous feed- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Threshold</head><p>Modification back documents in the way we discussed in the threshold determination section. However, that calculation may take unacceptably long time. Instead we adopt a simple method to adjust the existing thresholds only based solely on current feedback information.</p><p>Thresholds can be adjusted by calculating the optimal threshold for the extra feedback training set as discussed in threshold determination section. We denote the optimal threshold as optimal_threshold_extra_training, then the updated threshold is :</p><formula xml:id="formula_3" coords="6,123.09,177.63,362.94,8.96">updated_threshold = old_threshold + C (optimal_threshold_extra_training -old_threshold)</formula><p>where C is a learning parameter and is set to 0.3. We note that the feedback batch size and the learning parameter C are relevant parameters, if the feedback batch size is small, the optimal threshold for the extra feedback documents may vary a lot, one then choose a smaller C. C has to be chosen such that the updated thresholds change with the feedback process in a systematic and stable way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Submission Result and Discussions</head><p>Oracle submitted three runs. They are listed in the Table <ref type="table" coords="6,318.83,295.23,3.74,8.96" target="#tab_0">1</ref>, and Table <ref type="table" coords="6,370.69,295.23,3.74,8.96" target="#tab_2">2</ref>, with adaptive, batch runs in table 1 and routing in table2, respectively. The numbers in the parenthesis are the median value of all participants. The median values are the (N/2+1)-th value in sorted decreaseing list if the number of participants N is even. Except the precision for batch filter, all numbers in our submitted runs are above median.</p><p>We note that the routing behaves better than batch filtering. The fact that batch filtering system has only one more component: thresholding, than routing implies that our threshold determination is not quite good for batch filtering. In batch filtering, the threshold can not be adjusted. Once a threshold is determined, it is used to classify the whole test set without any adjustment. So the initial threshold determination is critical. However, it is interesting to note that the same simple method of determining threshold behaves quite well in adaptive filtering when comparing our adaptive filtering result with others.</p><p>Our training, classifying, and thresholding methods are all well-known methods, but our system behaves better than medians, especially in adaptive filtering. One explanation for this might be the linguistic suite in Oracle Text and knowledge base we used to process documents. The theme vector we get from Oracle Text contains more information than just text token and occurrence frequency in the document. Theme vector have a list of normalized terms. This term normalization could reduce the size of collection thesaurus, and make it easier to match different terms with the same concept. The weight of the theme contains not only the occurrence frequency information, but lexical information. In conclusion, the combination of these linguistic functionalities and appropriately engineering some well-known learning methods are believed to make our system successful. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Question Answering based on Information Retrieval and Information Extraction</head><p>Questions can be classified into pre-defined categories. Typical categories are: person names, organization names, dates, locations (cities, countries, states, provinces, continents), numbers, times, meaning of acronyms and abbreviations, weights, lengths, temperatures, speed, manner, duration, products, reasons etc. <ref type="bibr" coords="7,105.06,263.07,22.46,8.96">[7][8]</ref> Information extraction (IE) techniques allow us to extract lists of semantic categories from text automatically <ref type="bibr" coords="7,142.46,299.07,12.09,8.96" target="#b8">[9]</ref>, such as person names, organization names, dates, locations, duration, etc., which are subsets of the whole pre-defined question categories. If a question category is covered by IE, finding the locations of answer candidates becomes easier: the task remains is to rank the list of answer candidates extracted by IE. Otherwise, a number of heuristics are employed to locate the answer candidates and rank them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview of Oracle Q/A system:</head><p>Our Q/A system consists of three major components shown in figure2: (1) question processor (2) sentence ranking ( <ref type="formula" coords="7,126.89,395.06,3.86,8.96">3</ref>) answer extraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Question Processor:</head><p>Its role is to: (a) classify a question into a list of pre-defined semantic categories (b) extract content words from a question and send them to Oracle to retrieve relevant documents.</p><p>To classify a question, the first step is to determine its question type. The following wh-words are used to determine the question types: who, why, where, whom, what, when, how much money, how much, how many, how (rich, long, big, tall, hot, far, fast, large, old, wide, etc.).</p><p>A list of heuristics will help to map the question types to the pre-defined semantic categories:</p><p>(1) who is (was) "person name" =&gt; occupation <ref type="bibr" coords="7,90.09,539.06,11.58,8.96" target="#b1">(2)</ref>    A complicated problem is to map the question type "what" to its semantic category. Here, a part-of-speech (POS) tagger is used to assign the most appropriate part-of-speech for each word in a question based on the contextual information <ref type="bibr" coords="8,186.98,502.35,15.30,8.96" target="#b9">[10]</ref>. The head noun of the first noun phrase in a question is used to decide its semantic category. For example, "What costume designer decided that Michael Jackson should only wear one glove?" The head noun of the first noun phrase is "designer". Using WordNet's lexicon <ref type="bibr" coords="8,463.07,526.35,15.30,8.96" target="#b10">[11]</ref>, one finds that "designer" is a person, so, the semantic category of this question is "person name". If the head noun of the first noun phrase in a question is a stop word, then, the head noun of the second noun phrase is used to decide the semantic category. For example, "What was the name of the first Russian astronaut to do a spacewalk?" The head noun of the first noun phrase is "name" (a stop word), so, the head noun of the second noun phrase "astronaut" is used to decide the semantic category. Similarly, WordNet's API can tell that its semantic category is "person name". When extracting a list of keywords from a question, our principle is to extract all content words, but ignore all non-content words. The distinction between these two types of words is that content words should appear in the relevant documents, but non-content words should not appear in the relevant documents. At lease, stop words and stop phrase (such as: how much, what time, what country) belong to non-content words. Furthermore, a list of heuristics is helpful to distinguish content words from non-content words. For example, "What is the length of coastline of the state of Alaska?", and "What is the Illinois state flower?" Word "state" is a non-content word in the first question, but a content word in the second question.</p><p>Removing non-content words as many as possible makes retrieved documents more focusing on the subject topic of the question and is very helpful for extracting right answers from retrieved documents. After the query processor extracts a number of content words from a question, two queries are formulated: one uses proximity operator "near" with maximum span size 25 to connect these words, the other uses "accum" operator to connect them. Near opearator find all query terms within specified span. Documents are ranked based on the frequencies and proximity of query terms in the document. Accum (accumulate) operator finds documents matching one or more query terms. Documents are ranked based on the sum of weights of the terms matched and frequency of the terms in the document. The first query has higher priority than the second one, because "near" operator always retrieves more relevant documents, but usually, the number of documents retrieved by "near" is not big enough, so, "accum" query is used to supplement it. Oracle Text retrieves a list of relevant documents (60 documents in trec10) based on the two queries. Then, the relevant documents are broken into paragraphs, the paragraphs are segmented into sentences. According to our experiments, it is suitable to extract long answers (250 bytes) from ranked paragraphs, but to extract short answers (50 bytes), the paragraphs must be further segmented into sentences.</p><p>Ranking the segmented sentences is based on the following information: (1) the number of unique content words in a sentence (2) tf and idf of each content word (3) total number of content words in a query (4) the smallest window size which contains all the unique content words in the sentence.</p><p>Our information extractor (IE) has two modules: one used for sentence filtering, the other used for answer extraction (IE-based answer extractor). If the semantic category of a question is covered by the IE, the IE is used for sentence filtering. Only selected sentences which satisfy the IE, are the candidates of the sentence ranking. For example, if the semantic category of a question is "person name", only the sentences which include at least one person name will participate the sentence ranking, all the rest of sentences are filtered out from answer extraction, because they do not include answers of the question. The IE was also integrated with sentence segmentation algorithm. The standard sentence delimiters are "?!.", followed by one or more spaces, then followed by a word whose first letter is a capital letter. There are many exceptional cases, such as Mr. Steve, St. Louis. The IE could recognize these exceptional cases, and guarantee the success of the sentence segmentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Answer Extraction:</head><p>After the sentences are ranked, top five of them are used to extract the answers. From previous description, our IE only covers a subset of the whole semantic categories. If the answer type of a question belongs to the subset, it is easy to extract answers using the IE. Otherwise, we concluded a number of heuristics, which help to extract answers. The sentence ranking algorithm can find the smallest window in a sentence, which contains all the content words in the sentence. This window divides the sentence into three parts: (1) the words in front of the window, (2) the words after the window and (3) the words inside of the window. According to our observation, the priorities of the three parts are (1) (3) (2). We further observed that in (1) and ( <ref type="formula" coords="9,110.90,550.94,3.53,8.96">3</ref>), the words closer to the windows have higher priority than others. Based on these observations, we picked up certain percent of words from each part of the sentence according to their priorities to form the final answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Other Linguistic Processing:</head><p>(1) acronyms and abbreviations: like other advanced search engines, our system also does limited automatic query expansion, mainly for queries with acronyms, abbreviations, etc. It expanded (a) acronyms of geographical terms, such as "U.S. = United States", "N.C. = North Carolina" (b) abbreviations of organization names, such as "YMCA = young mens christian association", "NBS = national bureau of standards"</p><p>(2) stemming: Oracle's search engine does not use Porter's stemmer. Our stemmer is more conservative, which obtains good precision, may hurt recall a little bit. To remedy this problem, extra stemming was added in rare situations. For example, "When did Hawaii become a state?", the main verb was stemmed as "$become".</p><p>(3) Information Extractor (IE): an information extractor was created over the last few months to recognize (a) person names (b) organization names (c) dates (d) number (e) locations (f) money expression (g) time (h) temperature (I) speed (j) weight (k) length (l) square measure (m) cubic measure (n) age, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Performance Evaluation:</head><p>A question answering system was created based on information retrieval and information extraction. Our study shows that traditional IR technique are not only useful to rank documents, but also to rank paragraphs and sentences. Finding the smallest window from a sentence which contains all the content words in it, is very helpful to extract answers when its semantic category is not covered by the IE, the window size is also an important factor to decide the sentence rank. The current (Oracle 9i) knowledge base is designed for information retrieval; for Q/A track, we found it necessary to expand the lexicon to cover wh-focus ontological facets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Web Track</head><p>As preparation, we investigated the TREC-10 web task using TREC-9 web track documents and queries. We also attempted to productize lessons learnt from our participation in Trec8 adhoc manual task. A set of different collections including TREC Web and Adhoc collections helped us in our effort to formulate generic techniques applicable across domain. Due to resource constraints, we were unable to work on Trec10 web track. Here we summarize our findings based on older collections. Our experiments in link analysis using Oracle intranet data indicate that link analysis adds little value to intranet search. Link analysis is a technique that helps bring order to an unorganized collection lacking central authority (such as web) by using popularity measure. A organized intranet will have clearly defined authorities for different subject matters.</p><p>IDF weighting used in tf-idf scoring is not very effective when the collection is pretty large (a couple of million documents) and number of terms in the queries is pretty high. If the queries are free-text queries, IDF weighting fails to distinguish between important and unimportant terms. Weighting techniques which weight terms inversely proportional to a factor of the frequency ratios (x times as rare terms get y times as much weight) seem to perform better in this situation. We saw significant improvement in R-precision by adopting this technique.</p><p>As the number of documents increases, the number of distinct score values supported by a system becomes important. Until recently Oracle Text used 100 distinct integers in the range of 1 to 100 for scoring. We found that allowing a million distinct values improves system IR quality computed in average precision by improving tie splitting. Even though number of relevant documents retrieved did not increase very significantly (about 3-4%), average precision increased by 10-15% (for example, Trec9 web track average precision improved from 0.11 to 0.125).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="5,238.53,678.09,161.90,9.83"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Adaptive filtering diagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="8,157.80,442.35,195.54,8.96"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Architecture of the Oracle Q/A System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="6,90.33,577.27,421.81,132.85"><head>Table 1 :</head><label>1</label><figDesc>Adaptive and batch filtering result with T10U optimization. The numbers in the parathesis are the median value for all participants.</figDesc><table coords="6,96.09,617.37,409.86,92.75"><row><cell>Run label</cell><cell>Run type</cell><cell>Optimi-zation</cell><cell>Precision (median)</cell><cell>Recall (median)</cell><cell>T10SU (median)</cell><cell>F-beta (median)</cell></row><row><cell>oraAU082201</cell><cell>adaptive</cell><cell>T10U</cell><cell>0.538</cell><cell>0.495</cell><cell>0.291</cell><cell>0.519</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(0.462)</cell><cell>(0.213)</cell><cell>(0.137)</cell><cell>(0.273)</cell></row><row><cell>oraBU082701</cell><cell>batch</cell><cell>T10U</cell><cell>0.556</cell><cell>0.353</cell><cell>0.249</cell><cell>0.450</cell></row><row><cell></cell><cell></cell><cell></cell><cell>(0.618)</cell><cell>(0.293)</cell><cell>(0.247)</cell><cell>(0.448)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" coords="7,96.09,70.87,288.37,98.89"><head>Table 2 :</head><label>2</label><figDesc>Routing result. The number in the parathesis is the median value for all participants.</figDesc><table coords="7,96.09,110.85,276.84,58.91"><row><cell>Run label</cell><cell>Run type</cell><cell>Mean average precision (median)</cell></row><row><cell>oraRO082801</cell><cell>Routing</cell><cell>0.104</cell></row><row><cell></cell><cell></cell><cell>(0.082)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" coords="10,90.09,250.95,325.54,68.96"><head></head><label></label><figDesc>The following table shows the evaluation result provided by NIST for our system</figDesc><table coords="10,97.53,274.95,214.20,44.96"><row><cell></cell><cell>strict</cell><cell>lenient</cell></row><row><cell>NIST score</cell><cell>0.477</cell><cell>0.491</cell></row><row><cell>% of correct answers</cell><cell>60.77%</cell><cell>62.60%</cell></row><row><cell>% of correct first answers</cell><cell>40.04%</cell><cell>40.85%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Using Trec8 and Trec9 collections, we identified a few simple flaws in our system which have been removed. On average, recall has increased by about <rs type="grantNumber">25%</rs> and precision at 10 has improved by more than 50%. We ran this out-of-box automatic system against TREC-8 adhoc task. Oracle TREC-8 manual task submission received an average precision score of 0.42. Out of 50 benchmark queries, performance (number of relevant retrieved) is tied for 10 queries, 20 won by manual and 20 won by automatic.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_z6K93sn">
					<idno type="grant-number">25%</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct coords="11,109.08,175.34,292.72,8.96" xml:id="b0">
	<monogr>
		<ptr target="http://technet.oracle.com/products/text" />
		<title level="m" coord="11,109.08,175.34,127.82,8.96">Oracle Technet Text Homepage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct coords="11,108.16,201.62,413.83,8.96;11,90.09,214.70,173.00,8.96" xml:id="b1">
	<analytic>
		<title level="a" type="main" coord="11,246.50,201.62,150.34,8.96">Oracle at Trec8: A Lexical Approach</title>
		<author>
			<persName coords=""><forename type="first">K</forename><surname>Mahesh</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Kud</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Dixon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,416.00,201.62,105.99,8.96;11,90.09,214.70,143.39,8.96">Proceedings of the Eighth Text Retrieval Conference (TREC-8)</title>
		<meeting>the Eighth Text Retrieval Conference (TREC-8)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,107.24,240.86,414.73,8.96;11,90.09,253.95,22.41,8.96" xml:id="b2">
	<monogr>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Schutze</surname></persName>
		</author>
		<title level="m" coord="11,234.34,240.86,221.67,8.96">Foundations of Statistical Natural Language Processing</title>
		<imprint>
			<publisher>MIT press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,108.30,279.99,413.94,8.96;11,90.09,293.07,207.19,8.96" xml:id="b3">
	<analytic>
		<title level="a" type="main" coord="11,265.78,279.99,149.38,8.96">Relevance weighting of search terms</title>
		<author>
			<persName coords=""><forename type="first">S</forename><forename type="middle">E</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">K</forename><forename type="middle">Sparch</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" coord="11,422.25,279.99,99.99,8.96;11,90.09,293.07,124.61,8.96">Journal of the American Society for Information Science</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="129" to="146" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,106.74,319.23,415.64,8.96;11,90.09,332.31,373.52,8.96" xml:id="b4">
	<monogr>
		<author>
			<persName coords=""><forename type="first">K</forename><forename type="middle">Sparck</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><forename type="middle">E</forename><surname>Robertson</surname></persName>
		</author>
		<idno>TR446</idno>
		<title level="m" coord="11,298.21,319.23,224.17,8.96;11,90.09,332.31,61.03,8.96">A probabilistic model of information retrieval: development and status</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Cambridge University Computer Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct coords="11,104.24,358.47,417.73,8.96;11,90.09,371.43,52.15,8.96" xml:id="b5">
	<analytic>
		<title level="a" type="main" coord="11,323.98,358.47,194.30,8.96">Training algorithms for linear text classifications</title>
		<author>
			<persName coords=""><forename type="first">D</forename><forename type="middle">D</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">P</forename><surname>Callan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">R</forename><surname>Papka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,100.26,371.43,37.32,8.96">SIGIR&apos;96</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct coords="11,104.74,394.35,417.32,8.96;11,90.09,406.35,174.44,8.96" xml:id="b6">
	<analytic>
		<title level="a" type="main" coord="11,245.93,394.35,166.29,8.96">Lasso: A tool for surfing the Answer Net</title>
		<author>
			<persName coords=""><forename type="first">Dan</forename><surname>Moldovan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Sanda</forename><surname>Harabagiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,430.90,394.35,91.16,8.96;11,90.09,406.35,144.73,8.96">the Proceedings of the Text Retrieval Conference (TREC-8)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,108.45,430.35,413.51,8.96;11,90.09,442.35,251.73,8.96" xml:id="b7">
	<analytic>
		<title level="a" type="main" coord="11,264.50,430.35,219.04,8.96">Falcon: Boosting Knowledge for Answer Engines</title>
		<author>
			<persName coords=""><forename type="first">Sanda</forename><surname>Harabagiu</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Dan</forename><surname>Moldovan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,509.74,430.35,12.22,8.96;11,90.09,442.35,217.46,8.96">the Proceedings of the Text Retrieval Conference (TREC-9</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,104.82,466.35,417.36,8.96;11,90.09,478.34,196.74,8.96" xml:id="b8">
	<analytic>
		<title level="a" type="main" coord="11,217.05,466.35,220.81,8.96">Information Extraction Supported Question Answering</title>
		<author>
			<persName coords=""><forename type="first">Rohini</forename><surname>Srihari</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Wei</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,456.94,466.35,65.24,8.96;11,90.09,478.34,169.68,8.96">the Proceedings of the Text Retrieval Conference (TREC-8)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,110.70,502.34,411.48,8.96;11,90.09,514.34,46.62,8.96" xml:id="b9">
	<analytic>
		<title level="a" type="main" coord="11,156.11,502.34,267.34,8.96">Some Advances in Transformation-Based Part of Speech Tagger</title>
		<author>
			<persName coords=""><forename type="first">Eric</forename><surname>Brill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,444.17,502.34,78.01,8.96;11,90.09,514.34,19.27,8.96">the Proceedings of AAAI</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="11,109.20,538.34,403.51,8.96" xml:id="b10">
	<analytic>
		<title level="a" type="main" coord="11,161.14,538.34,119.57,8.96">WordNet: A Lexical Database</title>
		<author>
			<persName coords=""><forename type="first">G</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" coord="11,287.49,538.34,109.04,8.96">Communication of the ACM</title>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="39" to="41" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
